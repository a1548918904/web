<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript-Note</title>
    <link rel="icon" href="../../logo/java-script.png" />
    <link rel="stylesheet" href="../css/reset.css" />
    <link rel="stylesheet" href="../css/Js.css" />
    <script src="../js/myjs.js"></script>
</head>

<body>
    <div class='Floating_window'>
        <a href="#" onfocus="this.blur()">
            <!-- onfocus="this.blur()"可以去除a标签点击之后外面的一圈虚线 -->
            <img src="../../logo/up.png" alt="" style="width: 100%;">
        </a>
    </div>
    <div class="Title_text">
        <!-- 笔记标题 -->
        <div class="Title_text_d1">
            <div class="Title_input"></div>
            <div>
                <div class="Title_h1">
                    <b>
                        <h1 class="Note_Title_h1_c_1 t_center">
                            <span style="color: tomato; font-size: 40px;">J</span>ava<span style="color: tomato; font-size: 40px;">S</span>cript
                        </h1>
                    </b>
                </div>
            </div>
        </div>
    </div>
    <div style="width: 100%;
        height: 35px;
        background-color: rgba(255, 138, 117, 1);">
        <!-- 热门导航 -->
        <div class="Popular_navigation">
            <div>
                <div>
                    <span style="color:#ececec">其他链接</span>
                </div>
            </div>
            <div>
                <div>
                    <a href="./myhtml.html" target=_blank onfocus="this.blur()">HTML(界面优化中)</a>
                </div>
            </div>
            <div>
                <div>
                    <a href="../../vue/vue基础代码/myvue.html" target=_blank onfocus="this.blur()">VUE(建设中)</a>
                </div>
            </div>
            <div>
                <div>
                    <a href="../../MintUI/note.html" target=_blank onfocus="this.blur()">MintUI(建设中)</a>
                </div>
            </div>
            <div>
                <div>
                    <a href="https://www.github.com/icecream4k" target=_blank onfocus="this.blur()">GitHub</a>
                </div>
            </div>
        </div>
    </div>
    <!-- ----------------- -->
    <div class="Main_content">
        <div id="main">
            <div class="Note_Title_c_1" id="Note_Title_i_1">
                <div class="Title_input"></div><!-- 搜索框 -->
            </div>
            <div class="Note_Title_c_2" id="Note_Title_i_2">
                <div class="Note_Title_c_2_1">
                    <span style="font-size: 16px; color: tomato; font-weight: bolder;">
                        JavaScript简介:
                    </span>
                    <br />
                    <span style="color: tomato;">
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript(简称“JS”)
                    </span>
                    <span>
                        是一种具有函数优先的轻量级,解释型或即时编译型的高级编程语言。
                        虽然它是作为开发Web页面的脚本语言而出名的,但是它也被用到了很多非浏览器环境中,
                        JavaScript
                        基于原型编程、多范式的动态脚本语言,并且支持面向对象、命令式和声明式（如函数式编程）风格。
                    </span>
                </div>
                <div class="Note_Title_c_2_1">
                    <img src="../../logo/java-script.png" alt="">
                </div>

            </div>
            <br />
            <br />

            <div class="gird_layout">
                <!-- 笔记主体 -->

                <div class="gird_columns_1">
                    <!-- 导航栏 -->
                    <div class="gc1">
                        <span style="color: rgb(253, 142, 122);font-weight: bold;">--导航栏--</span>
                    </div>
                    <hr>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_1">打印示例</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_2">声明变量</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_3">变量赋值</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_4">数据类型</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_5">转换</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_6">运算符</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_7">弹出警示框</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_8">流程控制</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_9">循环</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_10">函数</a>
                    </div>
                    <br />
                    <div class="gc2">
                        <a href="#d_f_11">作用域</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_12">递归</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_13">匿名函数</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_14">对象</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_15">数组</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_16">字符串对象</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_17">Math对象</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_18">Date对象</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_19">Number对象</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_20">布尔对象</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_21">错误处理</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_22">正则表达式</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_23">正则使用</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_24">FUNCTION</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_25">面向对象</a>
                    </div>
                    <br>
                    <div class="gc2">
                        <a href="#d_f_26">ES5</a>
                    </div>
                </div>

                <div class="gird_columns_2">
                    <!-- 内容主体 -->
                    <span id="d_f_1"></span>
                    <div class="d_f_1">
                        <fieldset>
                            <legend>
                                <div>
                                    打印hello world示例
                                </div>
                            </legend>
                            <span style="color: skyblue;">console.log('<span style="color: tomato;font-size: 29px;">hello world</span>')</span><br />
                        </fieldset>
                    </div>

                    <br />
                    <br />
                    <span id="d_f_2"></span>
                    <div class="d_f_2">
                        <fieldset>
                            <legend>声明变量</legend>

                            <span id="q">var</span><span>&nbsp;x=1;</span><br />
                            <span>相当于声明了一个变量</span>
                            <span>console.log(x) - 即可在终端中打印x的值</span>
                            <span>
                                <span id="q">var</span> eid = 3;<br />
                                <span id="q">var</span> ename = 'tom';<br />
                                <span id="q">var</span> sex = 1;<br />
                                <span id="q">var</span> birthday = '1990-2-1';<br />
                                <span id="q">var</span> salary = 8000;<br />
                                <span id="q">var</span> deptId = 20;<br />
                                console.log(eid:',eid,'ename:',ename,'sex:',sex,'birthday:',birthday,'salary:',salary,'deptId:',deptId)
                            </span><br />
                            <span>结果:<span>
                                    3 ename: tom sex: 1 birthday: 1990-2-1 salary: 8000 deptId:
                                    20</span></span>


                        </fieldset>
                    </div>

                    <br />
                    <br />
                    <span id="d_f_3"></span>
                    <div class="d_f_3">
                        <fieldset>
                            <legend>变量赋值</legend>
                            <span id="q">var</span><span>&nbsp;d;</span>
                            <br />
                            <span>变量只是声明,但未赋值,则保存的值为undefined</span>
                            <br />
                            <span>变量可以被多次赋值,且赋不同类型的值,这个特点也是弱类型语言的特点</span>
                        </fieldset>
                    </div>

                    <br />
                    <br />
                    <span id="d_f_4"></span>
                    <div class="d_f_4">
                        <fieldset>
                            <legend>数据类型</legend>
                            <span>
                                检测数据类型<br />
                                查看任意数据的数据类型<br />
                                <span id="q">var</span> f1 = 3.14;<br />
                                consolo.log(typeof f1);<br />
                            </span>
                            <hr />
                            <span>
                                Unicode编码<br />
                                查看任意一个字符的Unicode码<br />
                                <span id="q">var</span> a = '韩';<br />
                                console.log('a',charCodeAt());<br />
                            </span>
                            <br />
                            <span>
                                基本数据类型<br />
                                <span id="q">var</span> x; // undefined<br />
                                <span id="q">var</span> userName = 'han'; string 字符串<br />
                                <span id="q">var</span> age = 18; number 数字类型<br />
                                <span id="q">var</span> y = True or False; boolean 布尔类型<br />
                                <span id="q">var</span> cars=["Saab","Volvo","BMW"]; array
                                数组<br />
                                <span id="q">var</span> b = null;
                                object(对象),常和引用类型的数据一起使用
                            </span>
                        </fieldset>
                    </div>
                    <br />
                    <br />
                    <span id="d_f_5"></span>
                    <div class="d_f_5">
                        <fieldset>
                            <legend>转换</legend>
                            <span>
                                隐式转换<br />
                                在运算过程中,自动发生的数据类型转换<br />
                                <span id="q">总结</span>:隐式转换中,如果加号中出现字符串,则数据转为字符串型;其它情况都是自动调用Number函数转为数值型<br />
                                数值型+字符串型 数值型转为字符串型<br />
                                <span id="q">var</span> a1 = 2+'3';<br />
                                console.log(a1,typeof a1); ==> 23 string
                                <hr />
                                数值型+布尔类型 布尔类型转化为数值型[true 1;false 0]<br />
                                <span id="q">var</span> a2 = 2 + false;<br />
                                console.log(a2,typeof a2); ==> 3 number
                                <hr />
                                字符串型+布尔型 布尔型转为字符串型<br />
                                <span id="q">var</span> a3 = '2' + true;<br />
                                console.log(a3,typeof a3); ==> '2true' string
                                <hr />
                                demo <br />
                                <span id="q">var</span> a = 1,<br />
                                b = true,<br />
                                c = "han";<br />
                                result1 = a + b + c;<br />
                                result2 = b + c + a;<br />
                                result3 = c + a + b;<br />
                                console.log('a + b + c的结果是',result1,'类型是:',typeof
                                result1); ==> '2han<br />
                                console.log('b + c + a的结果是',result2,'类型是:',typeof
                                result2); ==> 'truehan1'<br />
                                console.log('c + a + b的结果是',result3,'类型是:',typeof
                                result3); ==> 'han1true'<br />
                                <hr />
                                //
                                假设已经从数据库中获取到了商品的标题和价格,把这些数据打印成一行<br />
                                <span id="q">var</span> title = 'macbook pro';<br />
                                <span id="q">var</span> price = 15999;<br />
                                console.log('line 72-73>>>','商品名:',title,'价格:',price);
                                ==> 商品名: macbook pro 价格: 15999<br />
                                <hr />

                                <ul>
                                    强制转换
                                    <li>
                                        强制转字符串<br />
                                        <span id="q">var</span> num = 5;<br />
                                        <span id="q">var</span> new_num = num.toString();<br />
                                        console.log(num,typeof num); ==> 5 string
                                    </li>
                                    <li>
                                        强制转为整型<br />
                                        parseInt()常用于小数或者字符串转为整型,其他都是返回NaN<br />
                                        如果要转换的字符串中以数字开头,,则返回开头整数部分<br />
                                        如果要转换的字符串中非数字开头,则返回NaN<br />
                                        <span id="q">var</span> num = '1';<br />
                                        console.log(parseInt(num),typeof parseInt(num)); ==> 1
                                        string
                                    </li>
                                    <li>
                                        强制转为浮点型<br />
                                        parseFloat()它的用法和parseInt几乎一致,只是常用语将字符串转为浮点型<br />
                                        <span id="q">var</span> num = '3.14';
                                        console.log(parseFloat(num),typeof parseFloat(num)); ==>
                                        3.14 number
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br />
                    <br />
                    <span id="d_f_6"></span>
                    <div class="d_f_6">
                        <fieldset>
                            <legend>运算符</legend>
                            <span>
                                表达式:由数据或数据连接的运算符所组成的形式<br />
                                分为算术运算符,比较运算符,逻辑运算符,位运算符,赋值运算符,三目运算符
                            </span>
                            <hr />
                            <ul>
                                <li>
                                    <span>
                                        算术运算符<br />
                                        +&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/&nbsp;&nbsp;%&nbsp;&nbsp;++&nbsp;&nbsp;--<br />
                                        %&nbsp;取余<br />
                                        ++&nbsp;自增<br />
                                        --&nbsp;自减<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;<span id="q">var</span> d = 1;<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;console.log(d++); ==> 1<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;console.log(d); ==> 2<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;先打印一次结果,再执行自增<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;<span id="q">var</span> d = 1;<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;console.log(++d); ==> 2<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;console.log(d); ==> 2<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;先执行自增,再执行打印结果<br />
                                    </span>
                                </li>
                                <li>
                                    <span>
                                        比较运算符<br />
                                        &lt;&nbsp;&gt;&nbsp;&lt;=&nbsp;&gt;=&nbsp;==(等于)&nbsp;!=&nbsp;===(全等于)&nbsp;!==(不全等于)<br />
                                        ==比较值,会发生隐式转换,所以如果比较值和类型,推荐使用===,不等于和不全等类似<br />
                                    </span>
                                </li>
                                <li>
                                    <span>
                                        逻辑运算符<br />
                                        &&&nbsp;并且&nbsp;类似于Python中的and<br />
                                        ||&nbsp;或者&nbsp;类似于Python中的or<br />
                                        !&nbsp;非(逻辑非),取反<br />
                                    </span>
                                </li>
                                <li>
                                    <span>
                                        位运算符(了解)<br />
                                        2进制&nbsp;&nbsp;&nbsp;8进制&nbsp;&nbsp;&nbsp;10进制&nbsp;&nbsp;&nbsp;16进制等
                                    </span>
                                </li>
                                <li>
                                    <span>
                                        赋值运算符<br />
                                        = += -= *= /= %=
                                        ...等[计算赋值:先执行计算,然后执行赋值]<br />
                                    </span>
                                </li>
                                <li>
                                    <span>
                                        三目运算符<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;一目,由一个运算符链接的一个操作数据或表达式&nbsp;&nbsp;++&nbsp;&nbsp;--&nbsp;&nbsp;!<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;二目,由一个运算符链接的两个个操作数据或表达式
                                        + - *<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;三目,由两个运算符链接的三个个操作数据或表达式
                                        条件表达式 ? 表达式1 : 表达式2
                                        如果条件表达式为true,执行表达式1;如果条件表达式未false,执行表达式2<br />
                                    </span>
                                </li>
                            </ul>
                            <hr />
                            <ul>
                                短路逻辑
                                <li>
                                    <span>
                                        并且(&&),如果第一条条件为false,不再执行第二个条件<br />
                                        或者(||),如果第一个条件为true,不再执行第二个条件<br />
                                        查看一下程序是否报错:<br />
                                        <span id="q">var</span>&nbsp;num&nbsp;=&nbsp;3;<br />
                                        num&nbsp;&gt;&nbsp;5&nbsp;&&&nbsp;console.log(a);<br />
                                        num&nbsp;&lt;&nbsp;1&nbsp;&&&nbsp;console.log(a);
                                        ==>报错<br />
                                    </span>
                                </li>
                            </ul>
                        </fieldset>
                    </div>
                    <br /><br />
                    <span id="d_f_7"></span>
                    <div class="d_f_7">
                        <fieldset>
                            <legend>弹出警示框</legend>
                            <span>
                                此段已在JS中注释,搜索alertx<br />
                                alert() 弹出警示框<br />
                                prompt()
                                弹出提示(输入)框,需要使用变量保存用户输入的数据,类型是字符串型,如果用户点击取消返回null<br />
                            </span>
                        </fieldset>
                    </div>
                    <br /><br />
                    <span id="d_f_8"></span>
                    <div class="d_f_8">
                        <fieldset>
                            <legend>流程控制</legend>
                            <ul>
                                <li>
                                    <span>
                                        if语句<br />
                                        满 30 减 20<br />
                                        语法结构<br />
                                        if(条件){<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;语句1<br />
                                        }<br />
                                        满30减20<br />
                                        <span id="q">var</span>&nbsp;total&nbsp;=&nbsp;32;<br />
                                        if(total>=30){total-=20};<br />
                                        console.log(total)<br />
                                        练习:声明变量保存年龄,如果满18打印成年人<br />
                                        <span id="q">var</span>&nbsp;age&nbsp;=&nbsp;21;<br />
                                        if(age>=18){console.log('成年人')}<br />
                                        条件表达是中,一下几个数据会隐式转为false:<br />
                                        [0 NaN "" undefined null]
                                        这五个值作为条件出现,为false,其他都为true<br />
                                    </span>
                                </li>
                                <li>
                                    <span>
                                        if-else嵌套<br />
                                        用于多项分支语句<br />
                                        if(条件表达式1){语句1}else
                                        if(条件表达式n){语句n}else{语句n+1 //
                                        如果以上所有的条件表达式都是false,才会走这句话}<br />
                                    </span>
                                </li>
                                <li>
                                    <span>
                                        多向分支(和if类似)<br />
                                        switch-case语句<br />
                                        也是一种特殊的多想分支语句,是根据一个表达式的不同值来选择执行相应的语句<br />
                                        switch(表达式){<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;case 值1: //
                                        如果表达式的值为值1,泽执行下边的语句<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句1;<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
                                        值n:<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句n;<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:(类似于else)<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句<br />
                                        }<br />
                                        对比switch-case 和 if-else嵌套<br />
                                        switch-case在比较重只能进行全等于的比较,if-else可以使用各种比较运算,适用范围更广
                                    </span>
                                </li>
                            </ul>
                        </fieldset>
                    </div>

                    <br /><br />
                    <span id="d_f_9"></span>
                    <div class="d_f_9">
                        <fieldset>
                            <legend>循环</legend>
                            <span>
                                一遍又一遍执行相同或者相似的代码
                                <ul>
                                    循环的两个要素<br />
                                    <li>
                                        循环条件:控制循环的次数
                                    </li>
                                    <li>
                                        循环体:重复执行的相同或者相似的代码
                                    </li>
                                </ul>
                                <hr />

                                <ul>
                                    <li>
                                        while循环<br />
                                        while(循环条件){<br />
                                        循环体<br />
                                        }<br />
                                        <hr />
                                        break<br />
                                        在循环体重使用,用于强制结束循环,出现break后,循环体剩余语句及后续的循环不再执行<br />
                                        continue<br />
                                        跳过剩余部分的循环体,还会继续执行循环
                                        <hr />
                                        do-while循环<br />
                                        do{<br />&nbsp;&nbsp;循环体<br />}while(循环条件);
                                    </li>
                                    <li>
                                        for循环<br />
                                        for(初始值;循环条件;步长){<br />
                                        &nbsp;&nbsp;循环体<br />
                                        }
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br /><br />
                    <span id="d_f_10"></span>
                    <div class="d_f_10">
                        <fieldset>
                            <legend>函数</legend>
                            <span>
                                Number() , parseInt() , parseFloat() , alert()...<br />
                                分为系统函数和自定义函数<br />
                                函数:是一个功能体,接收若干个数据,产出新的结果<br />
                                函数用于封装反复执行的代码,便于后期的使用和维护
                                <ul>
                                    <li>
                                        普通函数<br />
                                        创建函数<br />
                                        function 函数名称(){<br />
                                        &nbsp;&nbsp;&nbsp;&nbsp;函数体 //封装的代码<br />
                                        }<br />
                                    </li>
                                    <li>
                                        带有参数的函数<br>
                                        function 函数名称(形参列表){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;函数体<br>
                                        }<br>
                                        调用(实参列表)<br>
                                        创建函数时候的参数称之为形参,调用函数时候的参数名称为实参,实参会赋值给形参
                                    </li>
                                    <li>
                                        带有返回值的函数<br>
                                        function 函数名称(参数列表){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;函数体<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;return值;&nbsp;//&nbsp;返回值,函数调用后返回的结果<br>
                                        }<br>
                                        return
                                        用于获取函数调用后的结果,如果函数中没有return或者有return没有加任何值,则返回undefined;return执行后,函数体中剩余的代码不再执行
                                    </li>
                                    <li>
                                        回调函数<br>
                                        传递的参数是另一个函数<br>
                                        目的:就是为了确保一个函数执行完以后,再去还行另一个函数
                                    </li>
                                    <li>
                                        全局函数(系统函数)<br>
                                        Number()/parseInt()/parseFloat()<br>
                                        encodeURL() 编码为一个URI,会把非英文字符进行编码<br>
                                        decodeURI() 将已编码的URI进行解码<br>
                                    </li>
                                    <li>
                                        验证编码转换后是否是NaN,是NaN -> True 不是NaN -> False<br>
                                        console.log(Number('1a'));<br>
                                        console.log(isNaN('1a'));<br>
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_11"></span>
                    <div class="d_f_11">
                        <fieldset>
                            <legend>作用域</legend>
                            <span>
                                <ul>
                                    <li>
                                        变量的作用域<br>
                                        函数的作用域:在函数中使用<span id="q">var</span>声明的变量,叫做<span style="font-weight: bolder;">局部变量</span>,只能在当前作用域下访问到<br>
                                        全局的作用域:在全局(函数外)声明的变量,叫做<span style="font-weight: bolder;">全局变量</span><br>
                                        函数中,不加var声明的变量自动就变成了全局变量<br>
                                        变量提升 - js程序执行之前,会把var声明的变量提升到所在作用域的最前边,但是赋值还是在原来的位置<br>
                                        函数中传递的形参是一个局部变量<br>
                                    </li>
                                    <li>
                                        函数的作用域<br>
                                        函数作用域:在函数中使用function关键字创建的函数,只能在当前函数下被调用<br>
                                        全局作用域:在全局下使用function关键字创建的函数,可以在任意作用域被调用<br>
                                        函数提升<br>
                                        使用function 关键字创建的函数,可以提升到所在作用域的最前边
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_12"></span>
                    <div class="d_f_12">
                        <fieldset>
                            <legend>递归</legend>
                            <span>
                                <ul>
                                    <li>
                                        递归<br>
                                        在函数的内部调用自身,默认是一个死循环<br>
                                        如何正确的使用递归:结合着return,要有结束的条件<br>
                                        递归算法:属于cpu密集型的算法,对cpu要求高<br>
                                        JS运算的时候属于是单线程,所谓的单线程,就是不管有多少个核心cpu,只是使用其中的一个内核
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_13"></span>
                    <div class="d_f_13">
                        <fieldset>
                            <legend>匿名函数</legend>
                            <span>
                                <ul>没有函数名称的函数 function(){}
                                    <li>
                                        创建函数<br>
                                        函数声明 : function fn(){}<br>
                                        函数表达式 : <span id="q">var</span> fun = function(){}<br>
                                        对比函数名称和函数名称()
                                        函数名称:不管哪种方式创建的函数,函数名称本质上就是一个变量,保存了一个函数<br>
                                        函数名称():调用函数,得到函数的返回结果<br>
                                        全局污染:全局变量出现会影响所有作用域的变量<br>
                                        开发原则:防止污染全局,尽量少用全局变量<br>
                                    </li>
                                    <li>
                                        匿名函数自调用<br>
                                        目的:创建函数作用域,防止污染全局<br>
                                        (function(){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;// 函数作用域,里边的变量是局部变量<br>
                                        })<br>
                                    </li>

                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_14"></span>
                    <div class="d_f_14">
                        <fieldset>
                            <legend>对象</legend>
                            <span>
                                属于引用类型数据<br>
                                对象是由一组属性和方法的集合<br>
                                属性侧重外观,名词;方法侧重功能,动词;
                                对象具体到某一个事物(万物皆对象)<br>
                                <ul>
                                    <li>
                                        JS中的对象<br>
                                        自定义对象,用户创建的对象<br>
                                        内置对象,JS提供的对象<br>
                                        宿主对象,根据不同的环境划分对象<br>
                                    </li>
                                    <li>
                                        自定义对象<br>
                                        自定义构造函数(JS 高级)
                                        对象字面量
                                    </li>
                                    <li>
                                        是用对象字面量创建对象<br>
                                        使用大括号{}创建空对象<br>
                                        属性名和属性值之间用冒号分开<br>
                                        多个属性之间用逗号分开<br>
                                        如果属性名中含有特殊字符必须添加引号,其他情况下引号可加可不加<br>
                                    </li>
                                    <li>
                                        访问对象中的属性<br>
                                        对象.属性名 推荐写法<br>
                                        对象['属性名']<br>
                                        如果属性名中含有特殊字符,必须使用中括号形式<br>
                                        如果访问不存在的属性,返回undefined
                                    </li>
                                    <li>
                                        删除属性<br>
                                        delete 对象.属性名<br>
                                        delete 对象['属性名']<br>
                                    </li>
                                    <li>
                                        使用内置构造函数创建对象<br>
                                        new Object() 创建一个空的对象,需要单独往对象中添加属性或方法
                                    </li>
                                    <li>
                                        遍历属性<br>
                                        依次访问对象中的每一个属性<br>
                                        for(<span id="q">var</span> key in 对象名){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;key // 获取属性<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;对象名[key] // 获取值<br>
                                        }
                                    </li>
                                    <li>
                                        检测属性是否存在<br>
                                        对象.属性名&nbsp;===&nbsp;undefined&nbsp;存在&nbsp;false&nbsp;不存在&nbsp;true<br>
                                        对象.hasOwnProperty('属性名')&nbsp;存在&nbsp;true&nbsp;不存在&nbsp;false<br>
                                        '属性名'&nbsp;in&nbsp;对象&nbsp;存在&nbsp;true&nbsp;不存在&nbsp;false
                                    </li>
                                    <li>
                                        对象中的方法<br>
                                        <span id="q">var</span> preson = {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;name:'han',<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;play:<span style="color: red;">function(){<br>
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this</span>.name /// this
                                        指代当前所在的对象<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: red;">}</span><br>
                                        }<br>
                                        person.play() // 调用对象中的方法
                                    </li>
                                    <li>
                                        引用类型数据的存储<br>
                                        见myjs.js 中 搜索'堆内存'
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_15"></span>
                    <div class="d_f_15">
                        <fieldset>
                            <legend>数组</legend>
                            <span>
                                其实JS中所有数组以及对象底层都是关联数组!本质上是没有索引数组!<br>
                                数组和对象底层,其实都是名值对的组合<br>
                                每个数组的下标和对象属性的属性名,都是字符串类型<br>
                                无论访问数组的元素,还是访问对象的属性,标准写法都是['下标名称']<br>
                                简写:
                                如果下标名称不是数字,可以简写为 .下标名称 <br>
                                如果下标是数字,只能简写为 [下标] ,不能用,因为'.数字'和程序中小数点冲突了
                                <ul>
                                    <li>
                                        由多个元素组成的数据集合,每个元素就是一个数据<br>
                                        <span id="q">var</span> s1 = 'tom';<br>
                                        <span id="q">var</span> s2 = '蔡徐坤';<br>
                                        使用数组字面量创建数组<br>
                                        [元素1,元素2,...]
                                    </li>
                                    <li>
                                        访问数组中的元素<br>
                                        数组[下标]<br>
                                        下标是从0开始的,如果不存在的元素则返回undefined<br>
                                    </li>
                                    <li>
                                        使用内置构造函数创建数组<br>
                                        new Arrray(元素1,元素2...)<br>
                                        new Array(5) 初始化元素个数为5,需要单独添加每个元素,也可以添加更多个元素
                                    </li>
                                    <li>
                                        数组的长度<br>
                                        数组.length<br>
                                        可以在数组的末尾添加新的元素 数组[数组.length] = 值<br>
                                    </li>
                                    <li>
                                        数组的分类<br>
                                        索引数组:用0,1,2等整数作为下标<br>
                                        关联数组:用字符串作为下标,每个元素需要单独添加,不推荐使用,有相关需要要建议使用对象代替
                                    </li>
                                    <li>
                                        遍历数组元素<br>
                                        for-in<br>
                                        for(var key in 数组){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;数组[key] 每个下标对应的元素<br>
                                        }<br>
                                        既可以遍历关联数组,也可以遍历索引数组<br>
                                        使用循环<br>
                                        for(var i = 0;i&lt;数组.length;i++){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;i 代表下标<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;数组[i] 代表下标对应的元素<br>
                                        }<br>
                                        只能遍历索引数组
                                    </li>
                                    <li>
                                        API<br>
                                        JS中的API,表示预定义好的一些方法或函数<br>
                                        如何学习一个API -&gt; 了解API的作用;知道API需要哪些参数,哪些是必须的,哪些是可选的;返回结果;<br>
                                        应用程序编程接口<br>
                                        <hr>
                                        toString() 将数组转为字符串<br>
                                        <hr>
                                        join(str) 将数组转为字符串,默认是按照逗号分隔元素,也可以提供参数作为制定的分隔符,str就是制定的字符<br>
                                        <hr>
                                        concat(arr1,arr2..) 用于拼接多个数字,arr1,arr2 是要作为拼接的数组<br>
                                        <hr>
                                        slice(start,end)
                                        截取数组中的元素,返回一个新数组;start是开始的下标,end是结束的下标,不包含end;如果end为空表示截取到最后,如果下标为负数表示倒数<br>
                                        <hr>
                                        splice(start,count,value1,value2,...)删除数组中的元素,返回删除后的元素格式为数组,原数组会发生变化.start开始的下标,count删除的长度,value1,value2,...删除后补充的元素;如果count为空表示删除到最后,如果start为负数表示倒数<br>
                                        <hr>

                                        reverse() 翻转数组中的元素,不需要任何参数,返回翻转后的数组,原数组也会发生变化<br>
                                        <hr>
                                        sort() 对数组元素进行排序,默认是按照Unicode码从小到大,返回排序后的数组,对原数组也会发生变化;<br>
                                        按照数字排序<br>
                                        sort(function(a,b){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;return a-b; // 从小到大<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;return b-a; // 从大到小<br>
                                        })<br>
                                        <hr>
                                        push(value1,value2,...) 往数组的末尾添加元素,返回数组的长度,原数组会发生变化;value1,value2表示要添加的元素<br>
                                        <hr>
                                        pop() 删除数组末尾的一个元素,返回删除的元素,原数组会发生变化<br>
                                        <hr>
                                        unshift(value1,value2,...) 往数组的开头添加元素,返回数组的长度,原数组会发生变化;value1,value2表示要添加的元素<br>
                                        <hr>
                                        shift() 删除数组开头的一个元素,返回删除的元素,原数组会发生变化
                                    </li>
                                    <li>
                                        二维数组<br>
                                        数组中的每个元素还是数组<br>
                                        [[],[],[],[],...]<br>
                                        访问二维数组中的元素 数组[下标][下标]
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_16"></span>
                    <div class="d_f_16">
                        <fieldset>
                            <legend>字符串对象</legend>
                            <span>
                                包装对象:目的是为了让原始类型数据像引用类型数据一样,具有属性和方法<br>
                                JS中提供了3中包装对象:String Number Boolean<br>
                                new String() 构造函数,强制将数据转为字符串型,返回对象<br>
                                Srting() 普通函数,强制将数据转为字符串型,返回字符串(推荐写法)<br>
                                <hr>
                                转义字符<br>
                                转义字符本身的意义,在要转义的字符前面加反斜杠( \ )<br>
                                \' 将特殊的引号转成普通字符<br>
                                \n 将普通字符n转成换行符<br>
                                \t 讲普通字符t转成制表符 tab键效果
                                <hr>
                                <ul>
                                    API
                                    <li>
                                        length&nbsp;查看字符串长度
                                    </li>
                                    <li>
                                        charAt(n)&nbsp;查看下标对应的字符,也可以使用数组的写法,字符串[n]
                                    </li>
                                    <li>
                                        charCodeAt()&nbsp;查看字符对饮的Unicode码
                                    </li>
                                    <li>
                                        如果想通过Unicode转成字符,即在编码前面加上\u,如:&nbsp;'\u97e9'
                                    </li>
                                    <li>
                                        indexOf(str) 查找满足条件的第一个元素的下标&nbsp;如果找不到返回-1
                                    </li>
                                    <li>
                                        lastindexOf(str) 查找满足条件的最后一个元素的下标&nbsp;如果找不到返回-1
                                    </li>
                                    <li>
                                        toUpperCase() 将英文字母转大写
                                    </li>
                                    <li>
                                        toLowerCase() 将英文字母转小写
                                    </li>
                                    <li>
                                        slice(start,end) 截取字符串,start开始的下标,end结束的下标,如果end为空表示截取到最后,如果为负值表示倒数
                                    </li>
                                    <li>
                                        substring(start,end)
                                        截取字符串,start开始的下标,end结束的下标,如果end为空表示截取到最后,如果为负值自动转为0;start和end的值不分大小,顺序可以颠倒;
                                    </li>
                                    <li>
                                        split(str) 将字符串按照指定的字符切割为数组
                                    </li>
                                </ul>
                                <hr>
                                匹配模式(了解)<br>
                                用于字符串的查找及替换<br>
                                <ul>
                                    <li>
                                        search(str) 查找匹配的字符串,返回下表,如果找不到返回-1<br>
                                        /Han/i 正则表达式写法,i -> ignore 忽略大小写
                                    </li>
                                    <li>
                                        match(str) 查找匹配的字符串,返回满足条件的数组<br>
                                        g -> global 全局查找
                                    </li>
                                    <li>
                                        replace(str1,str2) 查找到匹配条件的字符串,并替换
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_17"></span>
                    <div class="d_f_17">
                        <fieldset>
                            <legend>Math对象</legend>
                            <span>
                                用于数学运算<br>
                                不需要创建对象,可以直接使用其中的API<br>
                                <ul>
                                    <li>
                                        PI 圆周率
                                    </li>
                                    <li>
                                        abs 获取绝对值
                                    </li>
                                    <li>
                                        ceil 向上取整
                                    </li>
                                    <li>
                                        floor 向下取整
                                    </li>
                                    <li>
                                        round 四舍五入取整
                                    </li>
                                    <li>
                                        max 取一组数字最大值
                                    </li>
                                    <li>
                                        min 取一组数字的最小值
                                    </li>
                                    <li>
                                        pow 取x的y次方
                                    </li>
                                    <li>
                                        random 取随机数,范围 0 ~ 1 &gt;=0 &lt;1
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_18"></span>
                    <div class='d_f_18'>
                        <fieldset>
                            <legend>Data对象</legend>
                            <span>
                                用于对日期时间的存储和计算
                                <ul>
                                    <li>
                                        创建date对象<br>
                                        new Date('2020/8/24 11:26:30')<br>

                                    </li>
                                    <li>
                                        new Date(2020,7,24,11,29,30) 月份0~11
                                    </li>
                                    <li>
                                        new Date() 当前操作系统时间
                                    </li>
                                    <li>
                                        new Date(1581234000000) 距离计算机元年毫秒数对应的日期时间;数据库中的时间也是通过这种方式来操作
                                    </li>
                                    <li>
                                        获取具体日期时间<br>
                                        getFullYear 获取年<br>
                                        getMonth 获取月 月份范围0-11 使用时需要+1<br>
                                        getDate 获取日<br>
                                        getHours 获取小时<br>
                                        getMinutes 获取分钟<br>
                                        getSeconds 获取秒<br>
                                        getDay 获取星期 星期范围0-6 对应星期日-星期六<br>
                                        getMilliseconds 获取毫秒数<br>
                                        getTime 距离计算机元年毫秒数<br>
                                    </li>
                                    <li>
                                        获取本地字符串格式<br>
                                        toLocaleString() 2020-8-24 16:35:06<br>
                                        toLocaleDateString() 2020-8-24<br>
                                        toLocaleTimeString() 16:35:06<br>
                                    </li>
                                    <li>
                                        修改日期时间<br>
                                        setFullYear<br>
                                        setMonth<br>
                                        setDate<br>
                                        setHours<br>
                                        setMinutes<br>
                                        setSeconds<br>
                                        setMilliseconds<br>
                                        setTime 设置距离计算机元年的毫秒数,又能覆盖所有日期时间
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_19"></span>
                    <div class="d_f_19">
                        <fieldset>
                            <legend>Number对象</legend>
                            <span>
                                Number() 转为数值,返回数值类型<br>
                                new Number() 转为数值,返回对象类型<br>
                                toString(n) 转为字符串型,设置数字的进制为n<br>
                                toFixed(n) 保留小数点后n位
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_20"></span>
                    <div class="d_f_20">
                        <fieldset>
                            <legend>布尔对象</legend>
                            <span>
                                Boolean() 转为布尔型,返回布尔型<br>
                                new Boolean() 转为布尔型,返回对象类型<br>
                                !!数据 隐式转为布尔型<br>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_21"></span>
                    <div class="d_f_21">
                        <fieldset>
                            <legend>错误处理</legend>
                            <span>
                                语法错误(SyntaxError):错误的使用了中文字符或缺少表达式、括号等<br>
                                引用错误(ReferenceError):使用了未声明的变量<br>
                                类型错误(TypeError):错误的使用了数据的类型,例如对象中的方法名称写错<br>
                                范围错误(RangeError):参数的使用超出范围<br>
                                自定义错误:程序员自己指定的错误<br>
                                错误会影响后续代码的执行<br>
                                try{<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;可能出错误的代码<br>
                                }catch(err){<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;err 捕获到的错误<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;出现错误才会执行这里边的代码<br>
                                }<br>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_22"></span>
                    <div class="d_f_22">
                        <fieldset>
                            <legend>正则表达式</legend>
                            <span>
                                在JS中,正则表达式通常用于两个字符串方法: search()和replace()<br>
                                search()方法 用于检索字符串中制定的子字符串,或者检索与正则表达式相匹配的子字符串,并返回子串的起始位置[下标]<br>
                                replace()方法 用于在字符串中用一些字符替换另一个字符,或替换一个与正则表达式匹配的子串<br>
                                示例:<br>
                                var str = 'this is test';<br>
                                var n = str.search(/test/i);<br>
                                输出结果为:8 则为test中t的下标位置<br>
                                示例:<br>
                                var str = 'can you help';<br>
                                var txt = str.replace(/you/i,'i');<br>
                                输出结果为:can i help 则替换了 you 为 i<br>
                                <ul>字符集
                                    <li>要匹配一位小写字母:[a-z] 共26个</li>
                                    <li>要匹配一位大写字母:[A-Z] 共26个</li>
                                    <li>要匹配一位字母:[A-Za-z] 共52个</li>
                                    <li>要匹配一位字母或数字:[0-9A-Za-z] 共62个</li>
                                    <li>要匹配一位汉字:[\n4e00-\u9fa5] 19968~40869 共20902个</li>
                                </ul>
                                <br>
                                <ul>预定义字符集
                                    <li>要匹配一位数字:\d 等效于 [0-9] (digit)</li>
                                    <li>要匹配一位字幕、数字或者_ : \w 等效于 [0-9A-Za-z] (word)</li>
                                    <li>要匹配一位空字符:\s 可以匹配空格、制表符Tab等空白 (space)</li>
                                    <li>要匹配所有文字(通配符): .</li>
                                    <li>所以、手机号规则可以进一步简写为: - 1[3-9]\d\d\d\d\d\d\d\d\d</li>
                                    <li>利用数量词进一步简写手机号规则 - 1[3-9]\d{9}</li>
                                </ul>
                                <ul>数量词
                                    <li>
                                        有明确数量边界的数量词<br>
                                        字符集{n} 表示字符集必须重复n次,不能多也不能少<br>
                                        字符集{n,m} 表示字符集至少重复n次,最多重复m次;比如\d{4,6} 表示4到6位数字<br>
                                        字符集{n,} 表示字符集匹配的内容至少重复n此,多了不限,比如:\d{6,}表示6位以上数字<br>
                                    </li>
                                    <li>
                                        没有明确数量边界的数量词<br>
                                        * 可有可无,多了不限 0个 &lt;=<br>
                                        ? 可有可无,最多一次 0个或1个 <br>
                                        + 至少一次,多了不限 1个 &lt;=<br>
                                        例如:
                                        <ol>
                                            <li>
                                                \s* 0个 &lt;=个的空格
                                            </li>
                                            <li>
                                                \s+ 1个 &lt;=个的空格
                                            </li>
                                            <li>
                                                \s? 0个或者1个空格
                                            </li>
                                        </ol>

                                    </li>
                                </ul>
                                <ul>
                                    选择和分组
                                    <li>
                                        选择,是指在多个子规则中选择其中一个进行匹配
                                    </li>
                                    <li>
                                        只要在多个子规则中选起义进行匹配时,就用选择
                                    </li>
                                    <li>
                                        | 选择符只分左右,不考虑单个字符
                                    </li>
                                    <li>
                                        分组,将多个子规则视为一组,再和分组外的规则匹配
                                    </li>
                                    <li>
                                        只要希望将多个子规则视为一个整体,再和其他规则匹配时,就用分组
                                    </li>
                                    <li>
                                        如何:其他规则(多个子规则)<br>
                                        例如:我(操|cao)
                                    </li>
                                    <li>
                                        定义完整手机号规则<br>
                                        +86 13212341234<br>
                                        0086 13212341234<br>
                                        13212341234<br>
                                        正则 : ((\+86|0086)\s+)?1[3-9]\d{9}
                                        <ul>

                                            <li>
                                                +86 或者 0086 [ +
                                                是正则有功能的特殊符号,可是这里不希望+当做特殊功能使用,只当做普通字符匹配,所以用\+阻止正则解析+为数量词,进行转义]
                                            </li>
                                            <li>
                                                至少一个空字符:\s+
                                            </li>
                                            <li>
                                                手机号开头的+86和0086,整体可有可无,而且最多只能出现一次:()?
                                            </li>
                                            <li>
                                                1
                                            </li>
                                            <li>
                                                3-9任选其一
                                            </li>
                                            <li>
                                                9位数字
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        定义完整身份证号规则:
                                        <ul>
                                            <li>
                                                15位数字:\d{15}
                                            </li>
                                            <li>
                                                2位数字\d\d
                                            </li>
                                            <li>
                                                最后一位:1位数字或者x:[0-9x]
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        一个字符串中三个位置比较特殊
                                        <ul>
                                            <li>
                                                字符串开头
                                            </li>
                                            <li>
                                                字符串结尾
                                            </li>
                                            <li>
                                                英文君子中的每个单词中间的空白位置
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        如果只希望匹配特殊位置上的关键词时,就可以用特殊符号表示特殊位置
                                        <ul>
                                            <li>
                                                ^ 表示字符串开头
                                            </li>
                                            <li>
                                                $ 表示字符串结尾
                                            </li>
                                            <li>
                                                \b 表示单词边界,可匹配:空格,标点符号,字符串开头和结尾等可将一个单词和其他单词分隔开的符号<br>
                                                只写\b什么也匹配不到,愿意是,\b是'零宽',之匹配位置,不匹配字符<br>
                                                例如 : you can you up 是8个边界
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_23"></span>
                    <div class="d_f_23">
                        <fieldset>
                            <legend>正则使用</legend>
                            <span>
                                String类型提供的正则相关的函数<br>
                                <ul>
                                    <li>
                                        查找敏感词:用正则查找一句话中包含的敏感词,共4中情况:
                                        <ol>
                                            <li>
                                                只查找一个固定的敏感词出现的位置<br>
                                                <span id="q">var</span> i = str.indexOf('敏感词')<br>
                                                在str中查找第一个"敏感词"出现的下标位置<br>
                                                意为:在str中查找第一个敏感词的位置<br>
                                                返回值:如果找到,则返回第一个敏感词在字符串中的下标,如果没找到则返回-1<br>
                                                问题:不支持正则!只能找到一种敏感词!
                                            </li>
                                            <li>
                                                用正则查找多种敏感词出现的位置:<br>
                                                <span id="q">var</span> i = str.search(/正则/)<br>
                                                意为:在字符串str中查找第一个符合正则要求的敏感词的位置<br>
                                                返回值:同indexOf完全一样;如果找到,则返回第一个敏感词在字符串中的下标,如果没找到则返回-1<br>
                                                问题:虽然在正则工具当中有个选项可以忽略大小写,但是正则表达式天生是区分大小写的<br>
                                                解决:在第二个/后加后缀i即可,意为 ignore 忽略大小写
                                            </li>
                                            <li>
                                                只查找第一个敏感词的内容和位置:<br>
                                                <span id="q">var</span> arr = str.match(/正则/i)<br>
                                                意为:在字符串str中查找第一个符合正则要求的敏感词的内容和位置<br>
                                                返回值:2种 如果找到,返回一个数组,2个元素 arr['0':'敏感词的内容','index':敏感词下标的位置]<br>
                                                如果想获得本次找到的关键词的内容:标准写法:arr['0'] 简写:arr[0]<br>
                                                如果想获得本次找到的关键词的下标位置:标准:arr['index'] 简写 arr.index<br>
                                                说明:0和index是不能改名,因为数组是match函数返回给我们的,不是我们自己创建的!<br>
                                                如果没找到,返回 null<br>
                                                总结:查找方法的返回值规律
                                                <ol>
                                                    <li>
                                                        如果原函数返回的是下标位置,如果找不到,都返回-1
                                                    </li>
                                                    <li>
                                                        如果原函数返回的是一个数组或一个对象,如果找不到,都返回null
                                                    </li>
                                                    <li>
                                                        ..
                                                    </li>
                                                </ol>
                                                查找所有敏感词的内容<br>
                                                <ol>
                                                    <li>
                                                        <span id="q">var</span> arr = str.match(/正则/g)
                                                    </li>
                                                    <li>
                                                        g: global,查找全部敏感词
                                                    </li>
                                                    <li>
                                                        返回值:如果找到敏感词,则返回一个数组,只包含所有敏感词的内容,不再包含每个敏感词的位置;如果找不到,返回null
                                                    </li>
                                                </ol>
                                            </li>
                                            <li>
                                                既查找每个关键词的内容,又查找每个关键词的位置<br>
                                                String 类型没有提供这种函数<br>
                                                RegExp 类型提供了一个reg.exec()函数
                                            </li>
                                        </ol>
                                    </li>
                                    <li>
                                        替换敏感词:将找到的敏感词替换成新的内容
                                        <ol>
                                            <li>
                                                简单替换:将所有敏感词都替换为统一的新值<br>
                                                变量 = str.replace(/正则/ig,'新值')<br>
                                                意为:替换字符串str中所有符合正则要求的敏感词为统一的新值<br>
                                                因为所有字符串类型都是不可变类型,所以,replace无权修改原字符串,而是返回替换后的新字符串。原字符串保持不变,所以,必须用变量接住返回值,才能获得替换后的新字符串<br>
                                                如果原函数返回的是一个数组或者一个对象,如果找不到,都返回null,强调:如果一个函数有可能返回null!一定先判断是不是null,再使用。并且为null的情况提供备选方案
                                            </li>
                                            <li>
                                                高级替换:根据每次找到的敏感词的不同,动态替换成不同的新值
                                                var 变量 = str.replace(/正则/ig,function(关键词){
                                                return 根据本次'形参'获得的敏感词内容,动态生成一个新值
                                                })
                                                <ol>原理:回调函数的学习,可以靠打桩来判断执行次数,传入参数和返回值
                                                    <li>
                                                        replace会用正则表达式去查找str中所有符合正则要求的敏感词
                                                    </li>
                                                    <li>
                                                        每找到一个敏感词就自动调用一次回调函数
                                                    </li>
                                                    <li>
                                                        每次掉用回调函数时,都自动将本次找到的一个敏感词内容传给形参变量
                                                    </li>
                                                    <li>
                                                        回调函数中根据本次找到的敏感词内容,动态生成一个新值,返回出来
                                                    </li>
                                                    <li>
                                                        replace函数获得回调函数返回的新值,并替换到字符串中本次找到的敏感词位置
                                                    </li>
                                                </ol>
                                            </li>
                                            <li>
                                                衍生操作:删除敏感词:其实就是将敏感词替换为空字符串<br>
                                                变量 = str.replace(/正则/ig,'')
                                            </li>
                                        </ol>

                                    </li>
                                </ul>
                            </span>
                            <hr>
                            <span>
                                切割字符串:按指定的切割福,把一个完整的字符串,切割为多段子字符串
                                <ul>简单切割:切割符是固定的
                                    <li>
                                        <span id="q">var</span> arr = str.split('切割符')
                                    </li>
                                    <li>
                                        按照字符串str中制定的切割符,将字符串切割为多段字符串
                                    </li>
                                    <li>
                                        返回值:包含切割后的多段字符串的数组
                                    </li>
                                    <li>
                                        强调:切割后的结果中,不包含切割符!
                                    </li>
                                </ul>
                                <ul>复杂切割:切割符个数是不确定的,但是却能找到规律
                                    <li>
                                        <span id="q">var</span> arr = str.split(/正则/);
                                    </li>
                                    <li>
                                        意为:按str中所有符合正则要求的切割符将字符串切割为多段子字符串
                                    </li>
                                    <li>
                                        强调:split中不用加g,也能自动找到所有符合条件的切割符!
                                    </li>
                                </ul>
                                <hr>
                                <ul>
                                    固定套路
                                    <li>
                                        问题:虽然数组和字符串都有下标,但是因为字符串和数组不是同一类型,所以字符串用不了数组加的函数
                                    </li>
                                    <li>
                                        解决:先将字符串大三委一个一个字符组成的字符数组,然后就可以调用数组加的函数,只不过加工后,一定要拼接回字符串
                                    </li>
                                    <li>
                                        如何将字符串打散为字符数组:用空字符串''切割:str.split('');
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_24"></span>
                    <div class="d_f_24">
                        <fieldset>
                            <legend>FUNCTION</legend>
                            <span>
                                <ul>
                                    <li>
                                        正则表达式对象<br>
                                        内存中专门保存一条正则表达式并提供用正则表达式执行查找和验证的函数的对象<br>
                                        因为正则表达式的语法不是js语法,所以要用正则表达式对象让js能认得出来<br>
                                        今后只要在js中使用正则表达式都需要先创建正则表达式对象<br>
                                        <ol>
                                            如何创建正则表达式对象:
                                            <li>
                                                标准,用new创建 : <span id="q">var</span> reg = new RegExp("正则","ig")<br>
                                                强调:如果写了双引号"",而不是双斜线//,那么斜线就不用写了
                                            </li>
                                            <li>
                                                简写,用双斜线//创建<br>
                                                <span id="q">var</span> reg = /正则/ig<br>
                                            </li>
                                            <li>
                                                问题:正则表达式不是固定不变的,可能需要根据其他内容动态生成
                                            </li>
                                            <li>
                                                解决:今后如果正则表达式是固定的,首选<span id="q">var</span> reg =
                                                /正则/的方式创建;而如果不是固定的,需要动态生成,则首选new RegExp(js 表达式,'ig')
                                            </li>
                                        </ol>
                                        验证字符串格式
                                        <ol>
                                            <li>
                                                <span id="q">var</span> bool = reg.test(str)
                                            </li>
                                            <li>
                                                意为:用正则表达式reg,验证字符串str是否符合格式要求
                                            </li>
                                            <li>
                                                返回值:如果符合要求则返回true,不符合要求则返回false
                                            </li>
                                            <li>
                                                坑:test() 默认不要求从头到尾完全匹配,只要在字符串中可以找到部分内容和正则匹配,就会返回true;例如:abc123456
                                                /\d{6}/.test('abc123456') true
                                            </li>
                                            <li>
                                                解决:今后只要验证,都要在正则前加^后面加$,表示从头到尾必须完整匹配
                                            </li>
                                        </ol>
                                        查找每个敏感词的内容和位置:
                                        <ol>
                                            <li>
                                                问题:match()不加g,即可找到内容,又可以找到位置,但是不能找到所有;match()加g,虽然可以找到所有,但是只能获得内容,无法获得位置---鱼和熊掌不可兼得
                                            </li>
                                            <li>
                                                解决:reg.exec()<br>
                                                查找str中第一个敏感词的内容和位置,保存在一个数组中返回
                                            </li>
                                            <li>
                                                只使用一次:和match不加g的情况是一样的;也是只找第一个敏感词;也返回一个数组:[0:'敏感词内容',index:敏感词位置]
                                            </li>
                                            <li>
                                                如果希望用reg.exec()找所有敏感词的内容和位置<br>
                                                正则必须加g<br>
                                                反复调用reg.exec(str),知道reg.exec()返回null为止--用循环<br>
                                                reg.exec()知道自己要找下一个位置的敏感词<br>
                                                do{<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;<span id="q">var</span> arr = reg.exec(str);<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;if(arr!=null){<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获得敏感词的位置arr.index和内容arr.[0]<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;};<br>
                                                }while(arr!=null);
                                            </li>
                                        </ol>
                                    </li>
                                    <hr>
                                    <li>
                                        回顾函数<br>
                                        <ol>
                                            <li>
                                                什么是函数:程序中专门保存一段可重用的代码片段的程序结构,再起一个名字<br>
                                            </li>
                                            <li>
                                                只要一段代码可能被反复使用时,都要现将这段代码保存在函数中,后再反复使用函数<br>
                                            </li>
                                            <li>
                                                创建函数:<br>
                                                function 函数名(形参变量列表){<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;函数体;<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;return 返回值;<br>
                                                }<br>
                                            </li>
                                            <li>
                                                调用函数:var 变量 = 函数名(实参值列表)<br>
                                            </li>
                                            <li>
                                                形参变量:专门接收函数执行时必须的数据的变量,虽然没有var,但是是一个变量<br>
                                                定义形参是为了有些函数执行时,必须传入必要的数据,才能正常执行<br>
                                                今后只要一个函数执行时,必须外界传入某些数据才能正常执行,都需要定义形参变量
                                            </li>
                                            <li>
                                                返回值:一个函数的执行结果,被返回到函数外部<br>
                                                只要函数的调用者需要获得函数的执行结果时,都要定义函数的返回值
                                            </li>
                                        </ol>
                                    </li>
                                    <li>
                                        创建函数三种方式<br>
                                        <ol>
                                            <li>
                                                声明方式创建:<br>
                                                function 函数名(形参变量列表){<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;函数体<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;return 返回值<br>
                                                };<br>
                                                问题:会被声明提前 - 什么是声明提前:<br>
                                                [1]、在程序开始执行前;<br>
                                                [2]、程序会将var声明的变量和function声明的函数提前;<br>
                                                [3]、提前到当前作用域的顶部集中创建;<br>
                                                [4]、赋值留在原地<br>
                                                缺点:打乱程序正常执行顺序! -- JS语言广受诟病的缺陷!
                                            </li>
                                            <li>
                                                *用赋值方式创建*<br>
                                                var 函数名变量 = function(形参变量列表){函数体;return 返回值};<br>
                                                优点:函数不会被声明提前,保证了程序的正常执行顺序 -- 很多人都用赋值的方式创建函数<br>
                                                注意!:js中函数其实一个普通的变量,只不过对象中保存的是代码段不是数据而已;函数名其实就是一个很普通的变量
                                            </li>
                                            <li>
                                                用new 创建<br>
                                                var 函数名 = new Fcuntion('形参1','形参2',...,函数体;return '返回值');<br>
                                                很少用<br>
                                                但是揭示了:和其余函数创建之后的效果是一样的,不管是第一个还是第二个创建函数的方式,都是等效于new function()<br>
                                                结论:function底层等效于 new function() -> 本职是创建一个函数对象
                                            </li>
                                        </ol>
                                    </li>
                                    <li>
                                        重载<br>
                                        js语言不支持传统的重载方式 -- 多个同名函数<br>
                                        js中多个同名函数,只有最后一个函数会覆盖之前同名函数而存活下来<br>
                                        解决方式 -- 借助 arguments 对线来变相实现重载效果;arguments
                                        是每个函数自带的,不用创建可以直接使用,在调用函数时,能自动接收所有传入函数的实参值；并且是个类数组对象 -- 储存结果<br>
                                        需要根据传入实参值的不同,动态执行不同的逻辑<br>
                                        不好的做法:为同一件事儿,没中不同的逻辑,单独定义一个函数,起一个专门的函数名<br>
                                        增加了函数名和单词的数量,不好记忆,也不便于使用<br>
                                        好的解决方法--重载:相同函数名,不同参数列表的多个函数,在调用时,可根据传入的实参值不同,自动选择匹配的一个函数执行<br>
                                        只要根据传入的参数值不同,自动执行不同的逻辑时,都要用重载<br>
                                        减少了函数名和单词的个数,便于记忆和使用<br>
                                        使用方式:
                                        <ol>
                                            <li>
                                                使用arguments实现重载,之定义一个函数,只起一个统一的名字,不包含任何形参变量,函数内包含所有可能的逻辑
                                            </li>
                                            <li>
                                                根据arguments在调用时自动借助的实参值不同,可以在函数内动态判断决定本次该执行哪种逻辑
                                            </li>
                                        </ol>
                                        问题:既然JS中一个函数不定义形参,照样可以传实参,那么今后是不是可以不用定义形参了? -&gt; 不是! 自定义形参变量和arguments[i]
                                        自定义形参变量:简单,见名知意,可以告诉调用者如何正确使用函数<br>
                                        今后依然首选自定义形参变量 -- 只有参数个数不确定时,才被迫使用areguments
                                    </li>
                                    <li>
                                        匿名函数<br>
                                        定义函数时,不指定函数名的函数<br>
                                        为什么使用匿名函数? -&gt; 节约内存,划分临时作用域<br>
                                        <ol>何时使用
                                            <li>
                                                如果一个函数只使用一次时,都首选匿名函数
                                            </li>
                                            <li>
                                                如果希望划分临时作用域,避免不同功能之间变量相互污染时使用
                                            </li>
                                        </ol>
                                        <ol>
                                            <li>
                                                绝大多数回调函数,都是用匿名函数,因为匿名函数用完后,自动施放<br>
                                                如果不适用匿名函数,回调函数用完无法施放,浪费内存
                                            </li>
                                            <li>
                                                匿名函数自调用:定义一个匿名函数后,立刻调用自己<br>
                                                今后几乎所有js代码都要放在匿名函数自调中<br>
                                                为了避免使用全局变量,造成全局污染! -- 今后在开发中,禁止使用全局变量!<br>
                                                实现匿名函数自调用 (function(){要执行的函数})() // 创建匿名函数后,立刻执行<br>
                                                结果:匿名函数内用过的局部变量不会遗留在全能局,而是随匿名函数一起释放了<br>
                                                强调:匿名函数包余不包,对功能是没有影响的!但是对内存影响很大
                                            </li>
                                        </ol>
                                    </li>
                                    <li>
                                        作用域和作用域链<br>
                                        作用域:控制一个变量的可用范围<br>
                                        防止不同范围之间的变量互相污染<br>
                                        <ol>在js中共包括2级作用域
                                            <li>
                                                全局作用域<br>
                                                在函数function之外用var 创建的变量<br>
                                                专门保存全局变量的区域/储存空间<br>
                                                特点:随处可用,可反复使用! -- 也是全局变量的特点
                                            </li>
                                            <li>
                                                和函数作用域<br>
                                                在函数内部用var创建的变量;形参变量虽然没有var,但是也是局部变量
                                                专门保存仅函数内可用的变量的区域/存储空间<br>
                                                特定:仅函数内可用,不可重用! -- 也是局部变量的特点!
                                            </li>
                                            <li>
                                                总结 -- 如果函数内自己创建了所需的局部比那辆,则优先使用局部变量<br>
                                                如果函数内,自己没有创建所需的局部变量,则去全局去找来使用 -- 先局部,后全局
                                            </li>
                                            <li>
                                                函数作用域的本质:也是专门保存局部变量的对象
                                            </li>
                                        </ol>
                                        每个函数在定义时,函数对象上都包含一个所谓的'好友列表','好友列表'第一个格子,暂时为空,第二个格子指向window<br>
                                        当调用函数时,会临时创建本次函数调用的函数作用域对象；并且函数总是有限使用'好友列表'中离自己近的函数作用域对象中的局部变量;除非离自己近的函数作用域对象中,没有需要的局部变量,才被迫去全局window中拿全局变量使用
                                        -- 就近原则<br>
                                        ---- 局部变量都不可重用<br>
                                        <hr>
                                        作用域链(scope chain):<br>
                                        <ol>
                                            <li>
                                                函数对象中保存函数调用时所有可用的作用域对象的链式结构 -- 作用域链
                                            </li>
                                            <li>
                                                类似于'好友列表',学名就叫作用域链
                                            </li>
                                            <li>
                                                作用域链保存着一个函数可用的所有变量(局部变量和全局变量)
                                            </li>
                                            <li>
                                                作用域链控制着变量的使用顺序,先局部,后全局
                                            </li>
                                        </ol>
                                    </li>
                                    <li>
                                        闭包(closure)<br>
                                        <ol>
                                            <li>
                                                既重用一个变量,又保护变量不背篡改的一种编程方法
                                            </li>
                                            <li>

                                            </li>
                                        </ol>
                                        全局变量和局部变量都有不可兼得的优缺点<br>
                                        全局变量 - 可以重用;随处可以用,极易被污染<br>
                                        局部变量 - 仅函数内可用,不会被污染;不能重用<br>
                                        如果希望让一个函数既可重用一个变量,又保护这个变量不背篡改,都用闭包
                                        <ol>使用方式:
                                            <li>
                                                定义一个外层函数,包裹内层函数和要保护的变量 -- 内层函数成了外层函数内的局部函数,外部不可使用
                                            </li>
                                            <li>
                                                外层函数将内层函数返回到外部 -- 内层函数不要起名,因为外部接收之后,外部还会起名
                                            </li>
                                            <li>
                                                想使用内层函数的人,必须调用外层函数,来获得内层函数,才能使用
                                            </li>
                                        </ol>
                                        函数一次调用所产生的多个对象,共用一个变量使用<br>
                                        函数多次调用所长生的多个对象,各自有独立的变量使用<br>
                                        闭包的缺点 -- 比普通的函数多占用一块儿内存空间 -- 外层函数的函数作用域对象<br>
                                        解决方式:一旦一个闭包不再使用,应该尽快施放 用函数 = null即可
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_25"></span>
                    <div class="d_f_25">
                        <fieldset>
                            <legend>面向对象</legend>
                            <span>
                                <ol>什么是对象:
                                    <li>
                                        狭义解释:程序中专门保存现实中一个具体事物的属性和功能的程序结构
                                    </li>
                                    <li>
                                        广义的解释:js中除开五中原始类型(number,string,bool,null,undefined)之外,其余无法直接保存在变量中的数据类型都称为对象
                                    </li>
                                </ol>
                                <ul>
                                    什么是面向对象编程:程序显示都用对象结构集中存储一个事物的属性和功能,然后再按需调用对象中的属性和功能,这种做事方式,就称之为面向对象编程<br>
                                    为什么使用面向对象编程:便于大量数据的管理和维护<br>
                                    今后,几乎所有的项目,都是用面向对象的方式开发的<br>
                                </ul>
                                <ol>使用方式三步:
                                    <li>
                                        封装<br>
                                        <ul>
                                            <li>
                                                创建一个对象集中保存一个事物的属性和功能
                                            </li>
                                            <li>
                                                便于大量数据的管理和维护
                                            </li>
                                            <li>
                                                今后只要使用面向对象的方式编程,都要先创建对象
                                            </li>
                                            <li>
                                                如何创建对象:<br>
                                                <ul>
                                                    <li>
                                                        用{}来创建一个对象:{}是new Object()的简写<br>
                                                        var 对象名 = {<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;属性名1:属性值2,<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;属性名2:属性值2,<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;方法名:function(){..},<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;...<br>
                                                        };
                                                    </li>
                                                    <li>
                                                        用 new Object()创建<br>
                                                        创建一个空对象 - var 对象名 = new Object();<br>
                                                        强行向行对象中添加新属性和方法:<br>
                                                        对象名.属性名 = 属性值<br>
                                                        对象名.方法名 = function(){...}<br>
                                                        对象底层其实也是关联数组<br>
                                                        都是名值对的集合<br>
                                                        都可用['属性名']访问成员,都可以简写为.属性名<br>
                                                        . 其实是['']<br>
                                                        如果将来属性名不是固定的,来自于其他变量,则既不能写['变量'],又不能写.变量,只能写[变量]<br>
                                                        尝试获取对象或者一个不存在的属性,都不会报错,而是返回 undefined<br>
                                                        固定套路:判断一个对象中是否包含某个属性 - 对象.属性名!==undefined 说明包含,否则说明不包含<br>
                                                        尝试向对象或关联数组中不存在的属性强行赋值,都不会报错,而是自动添加该属性<br>
                                                        固定套路:给对象添加新属性或新方法:唯一的办法 - 强行赋值 ==> <br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;对象.新属性名 = 新;<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;对象.新方法名 = function(){...};<br>
                                                        都可以用for in循环遍历每个属性<br>
                                                        for(var 属性名 in 对象或关联数组){//in 会依次取出对象或关联数组中每个属性名,自动保存在in前的变量中}
                                                    </li>
                                                    <li>
                                                        用构造函数反复创建多个相同结构的对象:
                                                        <ol>
                                                            <li>
                                                                如果需要反复创建多个相同结构的对象时,用{}代码就很荣誉 -- 重复也不便于维护!
                                                            </li>
                                                            <li>
                                                                今后只要反复创建多个相同结构的对象时,都用构造函数来创建对象
                                                            </li>
                                                            <li>
                                                                先用构造函数定义同意类型多个对象的相同属性结构<br>
                                                                在用new 反复调用构造函数创建多个相同结构的对象<br>
                                                                构造函数 - 定义同意类型多个对象的相同树形结构的特殊函数<br>
                                                                function 类型名-一类对象的统一类型名(形参1,形参2){<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;//<br>
                                                                用this.属性名=xxx的方式,规定将来这类对象都必须有什么属性<br>
                                                                属性值不能写死,因为每个对象虽然树形结构相同,但是属性值各不相同,所以应该用形参变量来传入具体的值<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;this.属性名 = 形参1;<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;this.属性名 = 形参2;<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;this.方法名[将来的构造函数中不应该包含方法名] =
                                                                function(){<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..this.属性名...<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                                                };
                                                                new 做了几件事? :
                                                                1,创建了一个空对象、2,、3,调用构造函数,传入属性值实参,还自动将构造函数中的this全都指向new创建的新对象、
                                                            </li>
                                                        </ol>
                                                        构造函数的优点:重用对象结构代码<br>
                                                        问题:如果在构造函数中包含方法定义,则每创建一个对象,都会反复创建完全相同的函数对象的副本,而不是只创建一个所有对象公用 --
                                                        浪费了内存<br>
                                                        但是确实所有的对象都需要相同的方法<br>
                                                        将来用于对象试图访问一个子对象没有的共有方法或属性时,js程序现在子对象自身内部查找。如果子对象内部没有,js程序会自动延__proto__向父对象(原型对象)中查找是否包含要用的方法或属性。只要在父对象(原型对象)中查找到想要的方法,依然可以用'子对象.共有方法名()'调用,看起来就像子对象在用自己的方法一样<br>
                                                        构造函数的原型对象开始时是空的,如何向原型对象中添加共有属性和方法 -- 唯一的方法只有'强行赋值'<br>
                                                        构造函数.prototype.共有方法名 = function(){...}<br>
                                                        今后,只要所有子对象都要共有的方法或者属性值,都要集中保存在构造函数的原型对象中<br>
                                                        指同一个原型对象,从构造函数访问时,要用prototype属性,而从子对象访问时要用__proto__。构造函数的prototype属性和子对象的__proto__指的到底是同一个对象
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>如何访问对象中的成员:
                                                <ul>
                                                    <li>访问对象中的属性:对象名.属性名</li>
                                                    <li>调用对象中的方法:对象名.方法名()</li>
                                                </ul>
                                            </li>
                                            <li>this
                                                <ol>
                                                    <li>
                                                        对象自己的方法中的内容,需要随着对象自己的属性值动态变化<br>
                                                        错误的解决方案 - 直接在方法中写属性名 - 导致报错:属性名 is not defined
                                                    </li>
                                                    <li>
                                                        对象不在方法的作用域链中<br>
                                                        方法默认只能在自己内部或全局作用域查找变量,无权擅自进入某个对象中查找属性<br>
                                                        对象的属性并不是去全局对象<br>
                                                    </li>
                                                    <li>
                                                        正确但是并不好的解决方案 - 在对象的方法中写死'对象名.属性名'<br>
                                                        让程序先找到指定名称的对象,. 运算符可以让程序进入对象中,读取对象的属性<br>
                                                        问题 - 耦合度太高,外部的对象名改变,也必须手动修改内部写死的对象名,一但忘记修改内部的写死的对象名,程序就会报错
                                                    </li>
                                                    <li>
                                                        正确且好的解决方法:this<br>
                                                        自动获得正在调用当前函数 . 前的对象的js关键词<br>
                                                        今后只要对象的方法想要使用对象自己的属性都必须加'this.'<br>
                                                        今后判断this指向哪里,一定不要看它定义在哪,只看调用时 . 前是谁
                                                    </li>
                                                </ol>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        继承<br>
                                        今后,只要同一类型所有子对象公用方法和属性值,都要集中保存在构造函数的原型对象中<br>
                                        构造函数.prototype.属性名/共有方法名 = 属性值/function(){...}<br>
                                        自有属性和共有属性:<br>
                                        <ol>
                                            <li>
                                                自由属性:保存在当前对象内部,仅归当前对象自己所有的属性
                                            </li>
                                            <li>
                                                共有属性:保存在原型对象中,归多个子对象共有的属性
                                            </li>
                                        </ol>
                                        获取属性值:无论自由属性,还是共有属性,都可以用'子对象.属性值'来获取<br>
                                        修改属性:
                                        <ol>
                                            <li>
                                                自有属性:应该用子对象直接修改,子对象.自有属性名 = 属性值
                                            </li>
                                            <li>
                                                共有属性错误的方式 - 用子对象.共有属性的方式 = 新值;因为共有属性供所有子对象公用,如果允许某一个子对象擅自篡改,则牵一发而动全身 --
                                                危险的操作 js禁止子对象修改原型对象中的共有属性;但是 - 如果强行用子对象.共有属性 =
                                                新值,js程序会自动给这个子对象添加一个自由的同名属性来保存新的属性值。而不会影响原型对象中的共有属性,从此这个子对象,在这个公用属性的使用上,与其他子对象分道扬镳<br>
                                                正确做法:共有属性,只能用原型对象修改:构造函数.prototype.共有属性 = 新值
                                            </li>
                                        </ol>
                                        内置对象的原型对象<br>
                                        ECMAScript标准中规定的,浏览器已经实现的对象或类型:<br>
                                        String Number Boolean Array Date RegExp Math(不是类型,已经是一个对象了) Error Function
                                        Object global(在浏览器里面被window代替)<br>
                                        什么是类型 - 构造函数 + 原型对象形成的整体<br>
                                        构造函数负责:创建该类型的子对象,构造函数中的所有属性会成为将来子对象内的自由属性<br>
                                        原型对象负责:集中保存该类型所有子对象共有的成员(属性值/方法),原型对象中的方法和属性值都会成为将来所有子对象的共有成员<br>
                                        如何知道数组家共有哪些函数 - 只要看类型.prototype中有哪些函数即可<br>
                                        Array,prototype.新函数名 = function(){<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;// this 今后调用这个函数的 . 前面的子对象<br>
                                        }<br>
                                        将来任何一个数组都可以.新函数名()<br>
                                        <hr>
                                        原型链<br>
                                        什么是原型链 - 由多级父对象,逐级集成,形成的链式结果<br>
                                        原型链保存着一个对象可用的所有属性和方法<br>
                                        原型链控制着属性和方法的使用顺序<br>
                                        问题 - 不同类型的子对象,调用toString(),输出的结果格式千差万别 - 所有内置类型的原型对象中,为了自己家孩子着想,已经重写了适合自己家孩子的toString()<br>
                                        但是,自己定义的类型中还没有重写toString()方法,非常不便于调试对象的内容
                                    </li>
                                    <li>
                                        多态
                                        什么是多态 - 一个函数,在不同情况下,表现出不同的状态
                                        其实多态分两种情况
                                        <ol>
                                            <li>
                                                重载(overload):一个函数,根据传入的实参值不同,执行不同的逻辑
                                            </li>
                                            <li>
                                                重写(override):在子对象中定义一个和父对象中成员同名的成员<br>
                                                为什么要定义重名的成员 - 因为从父对象继承来的东西,不总是都好用
                                            </li>
                                        </ol>
                                        今后,只要从父对象继承来的东西不好用,就得重写自己<br>
                                        只要在当前子对象中定义一个和父对象中不好用的成员同名的新成员即可<br>
                                        根据就近原则,优先使用子对象自己定义的。不再使用父对象中不好使用的--推翻<br>
                                    </li>
                                </ol>
                                <hr>
                                <ul>
                                    自定义继承<br>
                                    如果整个父对象都不是想要的,就可以自定义继承,简称就是换爹 - 其实可以修改一个对象的父对象<br>
                                    只更换一个对象的父对象 - 其实就是修改对象的__proto__继承新的父对象<br>
                                    子对象.__protp__ = 新父对象<br>
                                    有的浏览器不允许擅自修改__proto__ 解决方法 - Object.setPrototypeOf(子对象,新父对象) 等效于子对象.__protp__ = 新父对象<br>
                                </ul>
                            </span>
                        </fieldset>
                    </div>
                    <br><br>
                    <span id="d_f_26"></span>
                    <div class="d_f_26">
                        <fieldset>
                            <legend>ES5:ECMAScript标准的第五个版本</legend>
                            <span>
                                <ul>
                                    <li>
                                        严格模式 - 比普通的js运行机制要求更严格的新的运行机制
                                        js语言本身有很多广受诟病的缺陷
                                        今后几乎所有的js程序都必须运行在严格模式下
                                        在当前作用域顶部:'use strict'
                                        新规定
                                        <ol>
                                            <li>
                                                禁止给未声明过的变量赋值 - 旧js中:给未声明的变量赋值,不报错,而是在全局自动创建该变量<br>
                                                缺点 - 极易造成全局污染和歧义<br>
                                                启动严格模式之后,禁止给未声明的变量赋值 - 报错!<br>
                                                好处 - 大大减少了全局污染的可能!也避免了部分拼写错误!便于调试
                                            </li>
                                            <li>
                                                静默失败升级为错误<br>
                                                什么是静默失败 - 程序执行不成功,但也不报错<br>
                                                缺点 - 机器不便于程序的调试<br>
                                                启动严格模式 - 几乎将所有静默失败都升级为了错误<br>
                                                好处 - 便于程序调试<br>
                                            </li>
                                            <li>
                                                普通函数调用中的this不再指向windows,而是undefined<br>
                                                普通函数中的this默认指window<br>
                                                缺点 - 极大的增加了全局污染的概率<br>
                                                启动严格模式 - 普通函数调用中的this不再指向window,而是undefined
                                                好处 - this后不能随便加.xxx,加上就报错,所以有效的防止了因为this造成的全局污染
                                            </li>
                                            <li>
                                                禁用arguments.callee<br>
                                                什么是arguments.callee - 是在一个函数内自动获得当前函数本身的关键字<br>
                                                何时使用 - 递归调用时<br>
                                                如果在递归调用时,在函数内写死函数名,是非常不好的,因为 - 紧耦合,万一外部函数名发生了变化,总要记得修改内部写死的函数名,一旦忘记修改写死的函数名,程序立刻出错<br>
                                                所以 - 将来就算用递归算法,也不能在函数内写死函数名,应该用arguments.callee代替写死的函数名,自动获得当前函数本身,则与函数无关了<br>
                                                好处 - 从此及时修改了外部的函数名,函数内部一点都不用修改,保持不变即可<br>
                                                为什么禁用 - 其实不推荐使用递归调用<br>
                                                递归调用的问题 - 重复计算量太大<br>
                                                解决 - 绝大多数的递归都可以用循环来解决 -- 难度太高<br>
                                                如果使用递归算法可以轻松解决问题,又不影响效率,完全可以首选递归算法,值不过不要用arguments.callee了,依然在函数里面写死函数名<br>
                                                只有用递归算法非常影响效率时,才被迫寻找循环的算法来代替递归<br>
                                            </li>
                                        </ol>
                                    </li>
                                    <li>
                                        保护对象 - 阻止别人的程序对我们自己的对象执行不合理的非法的修改操作<br>
                                        <ol>
                                            <li>
                                                保护属性<br>
                                                问题 - js中的对象毫无自保能力,外界的程序可以随意修改对象中的属性<br>
                                                <ul>解决 - 在ES5标准中,每个对象中的每个属性,都变成一个微小的对象,每个属性的小对象中,都包含四个更小的属性<br>
                                                    <li>
                                                        value - 为当前属性保存属性值<br>
                                                    </li>
                                                    <li>
                                                        writable - 开关,控制是否可修改当前属性值<br>
                                                    </li>
                                                    <li>
                                                        enumerable - 开关,控制着是否可用for in遍历到该属性；强调 :只强调for in 防不住 . - 版隐藏<br>
                                                    </li>
                                                    <li>
                                                        configurable - 开关,两件事,控制前面的开关能否使用,控制是否可以修改该属性<br>
                                                    </li>
                                                </ul>
                                                如果修改开关的值来限制对属性的操作<br>
                                                错误 - 细微的开关属性,不能用.直接访问!<br>
                                                只能用专门的函数<br>
                                                只修改一个属性中的多个开关(重新定义属性) - Object.defineProperty(对象名,'属性名',{<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;开关明:true或false,<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;...<br>
                                                });<br>
                                                我们关上的开关,别人可以随意再打开 -- 相当于没有保护<br>
                                                今后只要修改 writable he enumerable 开关时,都要同时设置configurable:false<br>
                                                configurable开关一旦改为false,任何人不可逆,除非修改源代码!<br>
                                                <hr>
                                                同时修改多个属性的多个开关 - Object.defineProperty()一次只能修改一个对象的属性,如果对象中有很多属性都需要保护,则反复写Object.defineProperty()太麻烦了<br>
                                                Object.defineproperties(对象名,{<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;属性名:{<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开关:true或false,<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;},<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;属性名:{<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开关:true或false,<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;},<br>
                                                &nbsp;&nbsp;&nbsp;&nbsp;...<br>
                                                })<br>
                                                问题 - 开关只能机械的保护一种情况,无法灵活的设定自定义的保护条件;比如员工的年龄可以修改,但是必须基于18-65之间<br>
                                                解决 - 访问器属性<br>
                                                什么是访问器属性 - 不实际保存属性值,仅提供对其他数据属性的保护,这样的就叫访问器属性 -- 像极了保镖<br>
                                                如果需要用自定义的规则来限制用户对属性的操作时,都要用访问器属性<br>
                                                <ol>
                                                    使用步骤
                                                    <li>
                                                        先定义一个隐姓埋名且半隐藏的数据属性实际保存数据
                                                    </li>
                                                    <li>
                                                        请保镖:<br>
                                                        能够起名冒名顶替要保护的属性<br>
                                                        保镖一请就是一对:名字都是固定的 一个叫 get 一个叫 set<br>
                                                        因为保镖可以执行验证和加工等操作,所以两个保镖应该都是函数才对<br>
                                                        其中:get函数专门负责从受保护的数据属性中读取属性值;set函数专门负责接收新值,并且保存到受保护的数据属性上<br>
                                                        外界如何使用访问器属性<br>
                                                        前提 - 外界不知道有受保护的属性,也不知道自己访问的是访问器属性,更不知道还有get和set函数。外界只知道有一个属性可以获取和修改值,仅此而已<br>
                                                        当外界视图获取属性值时,访问器属性会自动调用get函数,从受保护的属性中取出值来<br>
                                                        当外界视图修改属性值时,访问器属性会自动调用set函数,并且把要修改的新值传给set函数的value形参,先验证,如果新值验证通过,才由set函数保存到受保护的变量中,如果验证不通过,则可以报错且不保存非法的属性值<br>
                                                    </li>
                                                </ol>
                                            </li>
                                            <li>
                                                保护结构 - 防止别人的程序擅自篡改对象的树形结构<br>
                                                <ol>三个级别
                                                    <li>
                                                        防止扩展:禁止给对象添加新属性<br>
                                                        Object.preventExtensions(对象)
                                                        问题:preventExtensions()只防添加,不防删除,如果一个对象所有属性都禁止删除,就必须给每个属性手工添加configurable:false<br>
                                                    </li>
                                                    <li>
                                                        密封 - 既禁止扩展,又禁止删除属性<br>
                                                        Object.seal(对象)<br>
                                                        原理 - 既自动调用preventExtensions();又自动设置所有属性的 configurable:false<br>
                                                        结论 - 今后,绝大多数对象,保护到seal级别就够了,一般用了seal就不用preventExtensions()了
                                                        示例 - 演示防拓展和密封
                                                    </li>
                                                    <li>
                                                        冻结:Object.freek0iuyul[ze(对象) 既禁止拓展,又禁止删除,甚至禁止修改所有属性值
                                                        Object.freeze(对象)
                                                        <ol>原理:3件事情
                                                            <li>
                                                                既自动调用 perventExtensions()
                                                            </li>
                                                            <li>
                                                                又自动设置所有属性的configurable:false
                                                            </li>
                                                            <li>
                                                                又自动修改所有属性的writable:false
                                                            </li>
                                                        </ol>
                                                        何时 - 绝大多数情况下,属性值还是应该可以修改的,所以不用冻结!如果一个对象被多个模块同时使用,最好精致修改属性值,否则任由其中一个模块修改公用对象的属性值,一定会牵一发而动全身
                                                    </li>
                                                </ol>
                                            </li>
                                        </ol>
                                    </li>
                                    <li>
                                        替换this - 有的时候函数中的this指向的对象,不是我们想要的<br>
                                        解决 - 其实如果函数中的this指向的不是我们想要的,我们是可以修改的<br>
                                        第一种改法 - 只在本次调用函数时,临时修改一次this指向的对象:要调用的函数 .call(替换this的对象) 调用一次函数执行并且临时替换函数中的this为()中制定的对象<br>
                                        问题 - 有时,多个实参值是放在一个数组中,整体给到函数的,而函数需要的确实分散的多个实参值,出现了不一致<br>
                                        解决 - 用apply()代替call() 调用的函数.apply(替换this的对象,数组),同时临时替换函数中的this为()中的第一个实参值指定的对象<br>
                                        另一种情况:基于原函数,创建一个新函数副本,并永久绑定this为指定对象<br>
                                        <hr>
                                        如果一个函数需要反复调用,但是每次都被迫用call()或apply()替换this,极其不方便<br>
                                        解决 - 完全可以'买'一个一模一样的新函数副本,在新函数副本中永久绑定想用的this<br>
                                        如何使用 - var 新函数名 = 原函数.bind(替换this的对象,固定实参值...)<br>
                                        注意 - 不是调用函数 而是创建一个和原函数一模一样的新函数<br>
                                        永久的替换新函数中的this为制定的对象<br>
                                        问题 - 如果每次调用函数时,个别实参值也是固定的,每次都需要传入需要传入固定的个别实参值 -- 很麻烦<br>
                                        解决 - 其实bind不但可以永久的绑定this,而且还能永久的绑定个别实参值<br>
                                        原理 - 完全可以'买'一个一模一样的新函数副本,在新函数副本中永久绑定想用的this,永久替换对应位置的形参变量为一个固定的值
                                    </li>
                                    <li>
                                        数组新函数
                                        <ol>
                                            <li>
                                                <ul>
                                                    <li>
                                                        every - 判断数组中是否所有元素都符合要求<br>
                                                        var 判断结果 = arr.every(function(元素值,下标,当前数组){<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;return 根据元素值,下标和当前数组,判断当前元素是否符合要求<br>
                                                        })<br>
                                                        每遍历一个元素,就会自动调用一次回调函数<br>
                                                        每次调用回调函数时,都会自动传入三个值<br>
                                                        第一个实参值 value - 自动收到当前正在遍历的元素值<br>
                                                        第二个实参值 index - 自动收到当前正在遍历的元素位置<br>
                                                        第三个实参值 arr - 自动收到当前every.前的数组对象<br>
                                                        回调函数中用传入的三个值验证是否是符合条件的要求,并将判断结果返回给every()函数<br>
                                                        如果本地回调函数返回的是true,说明当前元素符合要求,于是every会继续向后遍历,直到结束,如果遍历结束所有元素的验证结果都返回true,则整个every就返回true,说明整个数组中的所有元素都符合要求<br>
                                                        如果本次回调函数返回false,说明当前元素不符合要求,every就没必要继续循环,而是立刻退出执行,整个every返回false,说明数组不是所有元素都符合要求<br>
                                                    </li>
                                                    <li>
                                                        some - 判断数组中是否包含符合要求的元素
                                                        var 判断结果 = arr.some(function(元素值,下标,当前数组){<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;return 根据元素值,下标和当前数组,判断当前元素是否符合要求<br>
                                                        })<br>
                                                        如果回调函数当前元素的验证结果返回true,说明当前符合要求,则some立刻退出循环,不再继续执行,而且整个some返回true,说明当前数组包含至少一个符合要求的元素
                                                        如果回调函数当前元素的验证结果返回false，说明当前元素不符合要求，则some会继续向后执行，如果所有元素的验证结果都为false，则说明数组中没有符合要求的元素
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>
                                                遍历
                                                <ol>
                                                    <li>
                                                        forEach - 单纯简化for循环<br>
                                                        arr.forEach(function(value,index,arr){<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;对value,index或arr执行操作<br>
                                                        })<br>
                                                        每遍历一个元素,就会自动调用一次回调函数<br>
                                                        每次调用回调函数时,都会自动传入三个值<br>
                                                        第一个实参值 value - 自动收到当前正在遍历的元素值<br>
                                                        第二个实参值 index - 自动收到当前正在遍历的元素位置<br>
                                                        第三个实参值 arr - 自动收到当前every.前的数组对象<br>
                                                        回调函数中对当前元素之，数组中当前位置的元素执行相同的操作，不需要返回值<br>
                                                        for循环已经没有进一步简化的空间了，且每次都写for循环，太麻烦了了<br>
                                                        问题 - forEach是数组家的函数，只有遍历索引数组时，才能使用forEach，如果遍历类数组对象，虽然也是数字下表，但是不能使用forEach<br>
                                                    </li>
                                                    <li>
                                                        map - 遍历出原数组中每个元素值加工后，放入新数组中返回<br>
                                                        var 新数组= arr.map(function(value,index,arr){<br>
                                                        &nbsp;&nbsp;&nbsp;&nbsp;return 加工后的新元素值<br>
                                                        }<br>
                                                        原理 - arr.map()先创建一个空数组等待<br>
                                                        map()也自带for循环遍历原数组中每个元素<br>
                                                        每遍历到一个元素，就自动调用一次回调函数<br>
                                                        每次调用回调函数时,都会自动传入三个值<br>
                                                        第一个实参值 value - 自动收到当前正在遍历的元素值<br>
                                                        第二个实参值 index - 自动收到当前正在遍历的元素位置<br>
                                                        第三个实参值 arr - 自动收到当前every.前的数组对象<br>
                                                        回调函数中根据当前传入的元素值等信息，加工出一个新的元素值返回给map()<br>
                                                        map()会将收到的新元素值放入新数组中相同位置保存起来<br>
                                                        遍历结束,map()会将新数组返回出来 -- 原数组保持不变<br>
                                                        只要希望保护原数组不变，返回新数组供其他位置的代码时使用
                                                    </li>
                                                </ol>
                                            </li>
                                            <li>

                                            </li>
                                        </ol>
                                    </li>
                                </ul>
                            </span>
                        </fieldset>
                    </div>












                </div>
                <!-- 内容主体 -->
            </div>
            <!-- 笔记主体 -->
        </div>
        <!-- 笔记尾部 -->
    </div>
    <!-- 隔断 -->
    <!-- 页面底部信息 -->
    <div class="footer">
        <div class="footer_dup">
            <div class="footer_dup_d1 footer_dup_div">
                <ul>
                    <li><a href="#">关于我</a></li>
                    <li><a href="#">联系我</a></li>
                    <li><a href="#">用户协议</a></li>
                </ul>
            </div>
            <div class="footer_dup_d2 footer_dup_div">
                <ul>
                    <li><a href="#">测试参数</a></li>
                    <li><a href="#">测试参数</a></li>
                    <li><a href="#">侵权申诉</a></li>
                </ul>
            </div>
            <div class="footer_dup_d3 footer_dup_div">
                <div class="footer_dup_d3_qq">
                    <a href="#">
                        <img class="pointer footer_dup_d3_qq_img" src="../../logo/QQ.png" alt="" style="width: 65px;" />
                    </a>
                </div>
                <div class="footer_dup_d3_weixin">
                    <a href="#">
                        <img class="pointer footer_dup_d3_weixin_img" src="../../logo/weixin.png" alt="" style="width: 65px;" />
                    </a>
                </div>
                <div class="footer_dup_d3_email">
                    <a href="#">
                        <img class="pointer footer_dup_d3_email_img" src="../../logo/email.png" alt="" style="width: 65px;" />
                    </a>
                </div>
            </div>
        </div>
        <div class="footer_ddown">
            <div>
                <span>
                    by
                    Han:At first, I felt that I wanted to make a knowledge dictionary which can query faster, but I
                    found that there were some people around who needed to sort out similar knowledge. As one of the
                    fans of Eva nYou as an open source leader, I naturally wanted to help more people<br>
                    祝 —— 永远年轻,永远热泪盈眶</span>
            </div>
            <div>
                <span>
                    违法不良信息举报邮箱:969666859@qq.com |
                    违法不良信息举报电话:4000233233转3<br />
                </span>
                <span>
                    <img src="../../logo/police.png" alt="" style="width: 18px;" />
                    <a href="http://www.hangzhoujubao.com/">杭州市违法和不良信息举报中心</a>
                    | <a href="http://jbts.mct.gov.cn/">12318全国文化市场举报网站</a> |
                    <a href="mailto:userreport@bilibili.com">儿童色情信息举报专区</a> |
                    <a href="http://www.shdf.gov.cn/shdf/channels/740.html">扫黄打非举报</a><br />网上有害信息举报专区:<a href="https://www.12377.cn/">中国互联网违法和不良信息举报中心</a><br />
                    亲爱的市民朋友,浙江反诈中心专线电话“0571-81234567”系专门针对避免您财产被骗受损而设,如果你受骗了,先第一时间拨打专线,把汇款银行网点、对方卡号、开户人姓名这几项信息告诉反欺诈中心。<br />
                    公司名称:韩某人的知识笔记 | 公司地址:浙江省杭州市 |
                    电话:132xxxx9695<br />
                </span>
            </div>
        </div>
    </div>
</body>

</html>