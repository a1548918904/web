<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../../public_static_files/logo/vue.png">
    <title>脚手架</title>
    <style>
        .header_d1 {
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="header_d1">
        <h1><span style="color:#41b783 ;">Vue-Cli 脚手架</span>以及<span style="color: #bdcaab;">ES6</span>部分知识</h1>
    </div>
    <hr>
    <ul>
        <li>
            <h1>脚手架的安装和介绍</h1>
        </li>
        <li>
            <h3>
                什么是脚手架：已经具有核心功能的标准化的半成品项目
            </h3>
        </li>
        <li>
            <h3>为什么使用脚手架：</h3>
            <ul>
                <li>
                    标准化：凡是用vue脚手架工具生成的脚手架代码结构完全一样
                </li>
                <li>
                    半成品：因为脚手架已经包含了大量核心代码,开发人员无需重复配置项目,只要专注于自己个性化定制的部分内容即可！省事,效率高！
                </li>
            </ul>
        </li>
        <li>
            <h3>
                何时使用：今后所有企业中的前段项目都是在脚手架代码基础上开发的
            </h3>

        </li>
        <li>
            <h3>如何使用：2步</h3>

            <ul>
                <li>
                    先安装用于反复生成脚手架的命令行工具：(一只老母鸡)[不需要每个项目重复做]--在任意目录下都行<br>
                    npm i -g @vue/cli
                </li>
                <li>
                    再用脚手架命令行工具反复生成项目脚手架源代码(老母鸡下蛋)[每做一个新项目,都要重新做一遍]<br>
                    在想要创建项目的文件夹目录下运行：vue create 项目名<br>
                    结果：在这个文件夹目录下从无到有创建出一个具有核心功能的vue脚手架项目源代码<br>
                </li>
            </ul>
        </li>
        <li>
            <h3>vue create 项目名：安装步骤</h3>
            <ul>
                <li>
                    第一步,选择预设,推荐选择第二个的自定义
                </li>
                <li>
                    第二步,选择需要的内容,按空格选择<br>
                    ◉ Babel - 把es6,es7等新代码,翻译成es5的等效代码 必须要选<br>
                    ◯ TypeScript<br>
                    ◯ Progressive Web App (PWA) Support<br>
                    ◉ Router - 单页面应用的核心组件<br>
                    ◉ Vuex - 做项目必选<br>
                    ◯ CSS Pre-processors - 如果你的项目用了sass或者less才选这项<br>
                    ◯ Linter / Formatter - 代码格式检查工具,一定不要选,要求过于苛刻<br>
                    ◯ Unit Testing<br>
                    ◯ E2E Testing<br>
                </li>
                <li>
                    Use history mode for router?是否使用history格式作为路由格式 有服务端就选y,否则选n<br>
                    需要 提供服务器端支持 首页重定向 在生产环境中
                </li>
                <li>
                    Where do you prefer placing config for Babel, ESLint, etc.? <br>
                    你更喜欢把babel,eslint等的配置放在哪里 <br>
                    In dedicated config files <br>
                    放在各自独立的配置文件中<br>
                    In package.json <br>
                    所有配置统一放在一个package.json文件中<br>
                </li>
                <li>
                    Save this as a preset for future projects?<br>
                    是否保存本次配置为将来的预设 n 不保存<br>
                </li>
                <li>等待loding</li>
                <li>
                    看到 - 就算成功<br>
                    🎉 Successfully created project xzvue.<br>
                    👉 Get started with the following commands:<br>
                    结果：在当前目录下创建了一个指定名称的文件夹,其中包含vue项目脚手架核心代码<br>
                    如果自己开发项目或者做实验,可以删除.git文件夹<br>
                </li>
                <li>
                    首次运行半成品脚手架项目:
                    <ul>
                        <li>用VScode打开刚创建的新项目文件夹</li>
                        <li>右键点击package.json文件,在‘终端/命令行中打开’</li>
                        <li>在VScode弹出的对话框中,等待出现输入光标的提示后,再输入npm run serve</li>
                        <li>
                            结果,做了两件事
                            <ul>
                                <li>starting development server ... 启动了一个简易开发服务器</li>
                                <li>Compiled successfully 编译成功(把代码中浏览器中可能不认识的es6和es7代码转化成es5代码；压缩和打包代码,放入临时的开发服务器中,允许开发人员测试网页)</li>
                            </ul>
                        </li>
                        <li>
                            在vscode中打开npm run serve ,没修改一下代码,就 会自动重新编译运行。不用重复运行npm run serve
                        </li>
                    </ul>
                </li>
                <li>
                    浏览当前项目中的"网页":<br>
                    vs code 中,按住ctrl 点命令行中出现的链接地址 - http://localhost:8080/
                </li>
            </ul>
        </li>
    </ul>
    <hr>
    <h2>懒加载</h2>
    <ul>
        <li>
            问题：单页面应用首屏加载时,默认会讲所有页面组件的内容都下载到客户端,首屏加载非常慢
        </li>
        <li>
            解决：2种方式
            <ul>
                <li>
                    什么是：将每个页面的组件内容单独打包未一个文件,首屏加载时,仅加载首屏页面一个组件的文件。当用户正在看首屏时,在底层使用异步请求,悄悄下载其他页面组件的文件
                </li>
                <li>
                    优点：依然可减少向服务器发送请求的次数,依然可在客户端更换页面组件,提高加载效率
                </li>
                <li>
                    缺点：偷跑流量
                </li>
            </ul>
        </li>
    </ul>
    <h2>全局组件</h2>
    <ul>
        <li>
            在src文件夹/components文件夹下新建组件 .vue文件
        </li>
        <li>
            在组件.vue文件中编写组件的HTML内容,css内容,和js内容<br>
            问题：此时,这个组件只是一个普通的子组件,还不是全局组件
        </li>
        <li>
            让这个组件变成全局组件：在src文件夹/main.js 中 new Vue()之前
            <ul>
                <li>
                    引入全局组件.vue:import myHeader from './component/myHeader.vue'
                </li>
                <li>
                    将引入的组件对象变成全局组件:Vue.component('组件名',组件对象)<br>
                    比如:想把myHeader变成全局组件：Vue.component('my-header',MyHeader)
                </li>
            </ul>
        </li>
        <li>
            结果:在当前脚手架中任何位置都可以使用&lt;my-header&gt;标签引入全剧组件
        </li>
    </ul>
    <hr>

    <ul>
        <li>
            <h1>箭头函数</h1>
            ES6中的 箭头函数来定义函数<br>
            const func = (参数列表)=>{函数体}<br>
            const func = (n1,n2)=>{return n1+n2}<br>
            const func = n=>{n*n} # 如果参数列表里面只有一个参数的时候,括号是可以省略的<br>
            例如 函数中有多行代码的时<br>
            const test = () => {<br>console.log('hello world');<br>console.log('hello world');<br>}<br>
            例如函数代码块中只有一行代码时<br>
            const mul = (n1,n2) => n1 + n2;<br>
            console.log(mul(30,40));<br>
            <hr>
            <h3>箭头函数中的this</h3>
            <p>箭头函数中的this引用的是最近作用域的this</p>
            <p>问题 - 箭头函数中的this是如何查找的? : 向外层作用域中,一层层查找this直到有this的定义</p>
            <p>一旦是function包含的this,那么指向就肯定是window,如果是两个箭头函数嵌套的this,那么指向的肯定是外层的对象</p>


        </li>
        <li>
            <h1>Vue Cli</h1>
            <p>创建vue项目 - vue init webpack projectname</p>
            <p>vue程序执行流程</p>
            <ol>
                <li>
                    <p>
                        template
                    </p>
                </li>
                <li>
                    <p>
                        ast
                    </p>
                </li>
                <li>
                    <p>
                        rander
                    </p>
                </li>
                <li>
                    <p>
                        virtual dom
                    </p>
                </li>
                <li>
                    <p>
                        真实 DOM
                    </p>
                </li>
            </ol>
            <hr>
            <p>
                runtime-compiler()<br>
                template -> ast -> rander -> vdom -> ui<br>
                runtime-only(1,性能更高 2,下面的vue代码量更少)<br>
                rander -> vdom -> ui<br>
            </p>
            <ol>vue-cli 3和2版本的区别
                <li>
                    <p>
                        vue-cli 3 是基于 webpack 4 打造的,vue-cli 2还是 webpack 3
                    </p>
                </li>
                <li>
                    <p>
                        vue-cli 3 的设计原则是 '0配置' ,移除的配置文件根目录下的,build和config等目录
                    </p>
                </li>
                <li>
                    <p>
                        vue-cli 3 提供了 vue ui 命令,提供了可视化配置,更加人性化
                    </p>
                </li>
                <li>
                    <p>
                        移除了 static 文件夹,新增了 public 文件夹,并且index.html 移动到 public 中
                    </p>
                </li>
            </ol>


        </li>
        <li>
            <h1>Vue-Router</h1>
            <p>什么是前端渲染,什么是后端渲染</p>
            <ol>
                <li>
                    <p>后端渲染</p>
                    <p>jsp : java server page</p>
                    <p>早期的网站开发整个HTML页面是由服务器渲染的</p>
                    <p>服务器直接生产渲染好的对应的HTML页面,由控制器路由分配,返回给客户端显示</p>
                    <p>后端路由的缺点 - 整个页面的模块都是由后端人员来编写和维护;前端开发如果要开发页面,需要通过PHP或者java来编写页面</p>
                </li>
                <li>
                    <p>前后端分离</p>
                    <p>后端只负责提供数据,不负责任何阶段的内容</p>
                    <p>前端浏览器中显示的网页中的大部分内容,都是由前端写的js代码再浏览器中执行,最终渲染出来的网页</p>
                </li>
                <li>
                    <p>单页面富应用 SPA</p>
                    <p>SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</p>
                    <p>整个页面只有一个HTML页面</p>
                    <p>核心 - 改变URL,但是页面不进行整体的刷新</p>
                </li>
            </ol>
            <p>router-link的补充</p>
            <p>router-link 除了 to ,还有一些比较常用的其他属性</p>
            <p>tag - tag可以指定 router-link 之后渲染成什么组件,比如渲染成一个button或者一个li元素等等</p>
            <p>replace - replace不会留下history记录,所以在指定replace的情况下,后退键不能返回到上一个页面中</p>
            <p>不常用 >> active-class 当router-link对应的路由匹配成功时,会自动给当前元素设置一个router-link-active的class,可以设置active-class修改默认的名称</p>
            <hr>
            <h3>动态路由</h3>
            <ul>
                <p>在某些情况下,一个页面的path路径可能是不确定的,比如用户进入我们的页面的时候,希望是如下的路径</p>
                <li>
                    <p>/user/aaaa或者/user/bbbb</p>
                </li>
                <li>
                    <p>除了有前面的/user之外,后面还跟上了用户ID</p>
                </li>
                <li>
                    <p>这种path和Component的匹配关系,我们称之为动态路由(也是路由传递数据的一种方式)</p>
                </li>
            </ul>
            <hr>
            <h3>路由的懒加载</h3>
            <p>当打包构建应用时,javascript包会变得非常大,影响页面价子啊</p>
            <p>如果我们不能把不同路由对应的组件分割成不同的代码块,然后当路由被访问的时候才加载对应组件,这样就更加高效了</p>
            <p>路由懒加载做的事情 - 路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块,只有在这个路由被访问到的时候,才加载对应的组件</p>
            <p>在ES6中,可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;const Home = () => import('../components/Home.vue')</p>
            <h3>路由的嵌套</h3>
            <p>比如在home页面中,希望通过/home/news和/home/message访问一些内容</p>
            <p>一个路径映射一个组件,访问这两个路径也会分别渲染两个组件</p>
            <h3>传递参数的方式</h3>
            <ul>
                <h3>params的类型</h3>
                <li>
                    <p>配置路由格式:/router/:id</p>
                </li>
                <li>
                    <p>传递的方式:在path后面跟上对应的值</p>
                </li>
                <li>
                    <p>传递后形成的路径:/router/123,/router/abc</p>
                </li>
            </ul>
            <ul>
                <h3>query的类型</h3>
                <li>
                    <p>
                        配置路由格式:/router,也就是普通配置
                    </p>
                </li>
                <li>
                    <p>
                        传递的方式:对象中使用query的key作为传递方式
                    </p>
                </li>
                <li>
                    <p>
                        传递后形成的路径:/router?id=123./router?id=abc
                    </p>
                </li>
            </ul>
        </li>
        <hr>
        <h3>$route和$router的区别</h3>
        <p>所有的组件都继承自Vue的原型</p>
        <p>$router为VueRouter实例,想要导航到不同URL,则使用$router.push方法</p>
        <p>$route为当前router跳转对象,里面可以获取name,path,query,params等</p>
        <h3>导航守卫</h3>
        <p>网页标题是通过&lt;title&gt;来显示,但是SPA只有一个固定的HTML,切换不同的页面时,标题并不会改变</p>
        <p>但是我们可以通过javascript来修改&lt;title&gt;的内容.window.document.title = '新的标题'</p>
        <p>那么在Vue项目中,在哪里修改?什么时候修改比较合适呢</p>
        <p>我们比较容易想到的修改标题的位置是每一个路由对应的组件.vue文件中</p>
        <p>通过mounted声明周期函数,执行对应的代码进行修改即可</p>
        <p>但是当页面比较多时,这种方式不容易维护(因为需要再多个页面执行类似的代码)</p>
        <ul>
            <p>更好的方式 - 我们可以利用beforeEach来完成标题的修改</p>
            <li>
                <p>
                    首先,我们可以在钩子当中定义一些标题,可以利用meta来定义
                </p>
            </li>
            <li>
                <p>
                    其次,利用导航收尾,修改我们的标题
                </p>
            </li>
        </ul>
        <ul>
            <p>导航钩子的三个参数解析</p>
            <li>
                to : 即将要进入的目标的路有对象
            </li>
            <li>
                from : 当前导航即将要离开的路由对象
            </li>
            <li>
                next : 调用该方法后,才能进入下一个钩子
            </li>
        </ul>
        <hr>
        <h3>keep-alive与vue-router</h3>
        <ul>
            <li>
                keep-alive是Vue内置的一个组件,可以被包含在组件保留状态,或避免重新渲染
                <ul>
                    <li>
                        include - 字符串或正则表达,只有匹配的组件会被缓存
                    </li>
                    <li>
                        exclude - 字符串或正则表达式,任何匹配的组件都不会被缓存
                    </li>
                </ul>
            </li>
            <li>
                router-view也是一个组件,如果直接被包在keep-alive里面,所有路径匹配到的视图组件都会被缓存
            </li>
            <li>
                一但使用了keep-alive之后,就可以使用activated和deactivated两个判断当前组件是否会激活的函数
            </li>
        </ul>
        <hr>
        <h3>TabBar demo 实现思路</h3>
        <ol>
            <li>
                <p>如果在下方有一个单独的TabBar组件,你如何封装</p>
                <ul>
                    <li>
                        自定义TabBar组件,在APP中使用
                    </li>
                    <li>
                        让TabBar出于底部,并且设置相关的样式
                    </li>
                </ul>
            </li>
            <li>
                <p>TabBar中显示的内容由外界决定</p>
                <ul>
                    <li>
                        定义插槽
                    </li>
                    <li>
                        flex布局评分TabBar
                    </li>
                </ul>
            </li>
            <li>
                <p>自定义TabBarItem,可以传入 图片和文字</p>
                <ul>
                    <li>
                        定义TabBarItem,并且定义两个插槽:图片.文字
                    </li>
                    <li>
                        给两个插槽外层包装div,用于设置样式
                    </li>
                    <li>
                        填充插槽,实现底部TabBar的效果
                    </li>
                </ul>
            </li>
        </ol>
        <li>
            <h1>Promise</h1>
            <ul>
                <p>ES6中一个非常重要和好用的特性就是Promise</p>
                <li>
                    <ul>
                        <li>
                            但是除此接触到Promise会一脸懵逼,这TM是个什么东西
                        </li>
                        <li>
                            看看官方或者一些文章对它的介绍和用法,也是一头雾水
                        </li>
                    </ul>
                </li>
                <li>
                    <p>Promise到底是做什么的呢</p>
                    <ul>
                        <li>Promise是异步编程的一种解决方案</li>
                    </ul>
                </li>
                <li>
                    <p>那什么时候我们会来处理异步事件呢</p>
                    <ul>
                        <li>
                            一种很常见的场景应该就是网络请求了
                        </li>
                        <li>
                            我们封装一个网络请求的函数,因为不能立即拿到结果,所以不能像简单的3+4=7一样将结果烦返回
                        </li>
                        <li>
                            所以旺旺我们会传入另一个函数,在数据请求成功时,将数据通过传入的函数回调出去
                        </li>
                        <li>
                            如果只是一个简单的网络请求,那么这种方案不会给我们带来很大的麻烦
                        </li>
                    </ul>
                </li>
                <li>
                    <p>但是,当网络请求非常复杂时,就会出现回调地狱</p>
                    <ul>
                        <li>可以举例说明</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <h1>Vuex</h1>
            <ul>
                <p>Vuex是一个专门为Vue.js应用程序开发的状态管理模式</p>
                <li>
                    它采用集中式存储管理引用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化
                </li>
                <li>
                    Vuex也集成到Vue的官方调试工具 devtools extension,提供了诸如零配置的 time-travel调试,状态快照导入导出等高级调试功能
                </li>
            </ul>
            <ul>
                <p>状态管理是什么</p>
                <li>
                    状态管理模式,集中式存储管理这些词听起来就非常高大上,让人捉摸不透
                </li>
                <li>
                    其实,你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面
                </li>
                <li>
                    然后,将这个对象放在顶层的Vue实例中,让其组件可以使用
                </li>
                <li>
                    那么,多个组件是不是可以共享这个对象变量属性了呢
                </li>
            </ul>
            <ul>
                <p>等等,如果是这样的话,为什么官方还要专门出一个插件Vuex呢?难道我们不能自己封装一个对象来管理么?</p>
                <li>
                    当然可以,只是我们要先想想Vuejs给我们带来的最大遍历是什么?没错,是响应式
                </li>
                <li>
                    如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢?当然也可以,只是自己封装可能稍微麻烦一些
                </li>
                <li>
                    不用怀疑,Vuex就是为了提供这样一个多组件间共享状态的插件,用它就对了
                </li>
            </ul>
            <h3>
                有什么状态是需要再多个组件之间共享呢?
            </h3>
            <ul>
                <li>
                    如果开发大型项目,一定会遇到多个状态,在多个界面间的共享问题
                </li>
                <li>
                    比如用户的登录状态,用户名称,头像,地理信息等
                </li>
                <li>
                    比如商品的收藏,购物车中的物品等等
                </li>
                <li>
                    这些状态信息,我们都可以放在统一的地方,对它进行保存和管理,而且他们还是响应式的
                </li>
            </ul>
            <ul>
                <li>
                    <p>Vue已经帮我们做好了单个界面的状态管理,但是如果是多个界面呢?</p>
                    <ul>

                        <li>
                            多个视图都以来同一个状态(一个状态改了,多个界面都需要进行更新)
                        </li>
                        <li>
                            不同接麦你的Actions都想修改同一个状态(Home.vue需要更改,Profile.vue也需要修改这个状态)
                        </li>
                    </ul>
                </li>
                <li>
                    <p>也就是说对于某些状态来说只属于我们某一个视图,但是也有一这些状态,属于多个视图共同想要维护的状态</p>
                    <ul>
                        <li>
                            状态1/状态2/状态3放在自己的房间里面,自己管理自己用,没问题
                        </li>
                        <li>
                            但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理
                        </li>
                        <li>
                            Vuex就是为我们提供这个大管家的工具
                        </li>
                    </ul>
                </li>
                <li>
                    <p>全局单列模式</p>
                    <ul>
                        <li>
                            我们现在要做的就是将共享的状态抽取出来,交给我们的大管家,统一进行管理
                        </li>
                        <li>
                            之后,你们每个视图,都按照规定好的规定,进行访问和修改等操作
                        </li>
                        <li>
                            这就是Vuex背后的基本思想
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <h1>Axios</h1>
        </li>
    </ul>
</body>

</html>