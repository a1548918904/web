<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../../public_static_files/logo/vue.png">
    <title>脚手架</title>
    <style>
        .header_d1 {
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="header_d1">
        <h1><span style="color:#41b783 ;">Vue-Cli 脚手架</span>以及<span style="color: #bdcaab;">ES6</span>部分知识</h1>
    </div>
    <hr>
    <ul>
        <li>
            <h1>脚手架的安装和介绍</h1>
        </li>
        <li>
            <h3>
                什么是脚手架：已经具有核心功能的标准化的半成品项目
            </h3>
        </li>
        <li>
            <h3>为什么使用脚手架：</h3>
            <ul>
                <li>
                    标准化：凡是用vue脚手架工具生成的脚手架代码结构完全一样
                </li>
                <li>
                    半成品：因为脚手架已经包含了大量核心代码,开发人员无需重复配置项目,只要专注于自己个性化定制的部分内容即可！省事,效率高！
                </li>
            </ul>
        </li>
        <li>
            <h3>
                何时使用：今后所有企业中的前段项目都是在脚手架代码基础上开发的
            </h3>

        </li>
        <li>
            <h3>如何使用：2步</h3>

            <ul>
                <li>
                    先安装用于反复生成脚手架的命令行工具：(一只老母鸡)[不需要每个项目重复做]--在任意目录下都行<br>
                    npm i -g @vue/cli
                </li>
                <li>
                    再用脚手架命令行工具反复生成项目脚手架源代码(老母鸡下蛋)[每做一个新项目,都要重新做一遍]<br>
                    在想要创建项目的文件夹目录下运行：vue create 项目名<br>
                    结果：在这个文件夹目录下从无到有创建出一个具有核心功能的vue脚手架项目源代码<br>
                </li>
            </ul>
        </li>
        <li>
            <h3>vue create 项目名：安装步骤</h3>
            <ul>
                <li>
                    第一步,选择预设,推荐选择第二个的自定义
                </li>
                <li>
                    第二步,选择需要的内容,按空格选择<br>
                    ◉ Babel - 把es6,es7等新代码,翻译成es5的等效代码 必须要选<br>
                    ◯ TypeScript<br>
                    ◯ Progressive Web App (PWA) Support<br>
                    ◉ Router - 单页面应用的核心组件<br>
                    ◉ Vuex - 做项目必选<br>
                    ◯ CSS Pre-processors - 如果你的项目用了sass或者less才选这项<br>
                    ◯ Linter / Formatter - 代码格式检查工具,一定不要选,要求过于苛刻<br>
                    ◯ Unit Testing<br>
                    ◯ E2E Testing<br>
                </li>
                <li>
                    Use history mode for router?是否使用history格式作为路由格式 有服务端就选y,否则选n<br>
                    需要 提供服务器端支持 首页重定向 在生产环境中
                </li>
                <li>
                    Where do you prefer placing config for Babel, ESLint, etc.? <br>
                    你更喜欢把babel,eslint等的配置放在哪里 <br>
                    In dedicated config files <br>
                    放在各自独立的配置文件中<br>
                    In package.json <br>
                    所有配置统一放在一个package.json文件中<br>
                </li>
                <li>
                    Save this as a preset for future projects?<br>
                    是否保存本次配置为将来的预设 n 不保存<br>
                </li>
                <li>等待loding</li>
                <li>
                    看到 - 就算成功<br>
                    🎉 Successfully created project xzvue.<br>
                    👉 Get started with the following commands:<br>
                    结果：在当前目录下创建了一个指定名称的文件夹,其中包含vue项目脚手架核心代码<br>
                    如果自己开发项目或者做实验,可以删除.git文件夹<br>
                </li>
                <li>
                    首次运行半成品脚手架项目:
                    <ul>
                        <li>用VScode打开刚创建的新项目文件夹</li>
                        <li>右键点击package.json文件,在‘终端/命令行中打开’</li>
                        <li>在VScode弹出的对话框中,等待出现输入光标的提示后,再输入npm run serve</li>
                        <li>
                            结果,做了两件事
                            <ul>
                                <li>starting development server ... 启动了一个简易开发服务器</li>
                                <li>Compiled successfully 编译成功(把代码中浏览器中可能不认识的es6和es7代码转化成es5代码；压缩和打包代码,放入临时的开发服务器中,允许开发人员测试网页)</li>
                            </ul>
                        </li>
                        <li>
                            在vscode中打开npm run serve ,没修改一下代码,就 会自动重新编译运行。不用重复运行npm run serve
                        </li>
                    </ul>
                </li>
                <li>
                    浏览当前项目中的"网页":<br>
                    vs code 中,按住ctrl 点命令行中出现的链接地址 - http://localhost:8080/
                </li>
            </ul>
        </li>
    </ul>
    <hr>
    <h2>懒加载</h2>
    <ul>
        <li>
            问题：单页面应用首屏加载时,默认会讲所有页面组件的内容都下载到客户端,首屏加载非常慢
        </li>
        <li>
            解决：2种方式
            <ul>
                <li>
                    什么是：将每个页面的组件内容单独打包未一个文件,首屏加载时,仅加载首屏页面一个组件的文件。当用户正在看首屏时,在底层使用异步请求,悄悄下载其他页面组件的文件
                </li>
                <li>
                    优点：依然可减少向服务器发送请求的次数,依然可在客户端更换页面组件,提高加载效率
                </li>
                <li>
                    缺点：偷跑流量
                </li>
            </ul>
        </li>
    </ul>
    <h2>全局组件</h2>
    <ul>
        <li>
            在src文件夹/components文件夹下新建组件 .vue文件
        </li>
        <li>
            在组件.vue文件中编写组件的HTML内容,css内容,和js内容<br>
            问题：此时,这个组件只是一个普通的子组件,还不是全局组件
        </li>
        <li>
            让这个组件变成全局组件：在src文件夹/main.js 中 new Vue()之前
            <ul>
                <li>
                    引入全局组件.vue:import myHeader from './component/myHeader.vue'
                </li>
                <li>
                    将引入的组件对象变成全局组件:Vue.component('组件名',组件对象)<br>
                    比如:想把myHeader变成全局组件：Vue.component('my-header',MyHeader)
                </li>
            </ul>
        </li>
        <li>
            结果:在当前脚手架中任何位置都可以使用&lt;my-header&gt;标签引入全剧组件
        </li>
    </ul>
    <hr>

    <ul>
        <li>
            <h1>箭头函数</h1>
            ES6中的 箭头函数来定义函数<br>
            const func = (参数列表)=>{函数体}<br>
            const func = (n1,n2)=>{return n1+n2}<br>
            const func = n=>{n*n} # 如果参数列表里面只有一个参数的时候,括号是可以省略的<br>
            例如 函数中有多行代码的时<br>
            const test = () => {<br>console.log('hello world');<br>console.log('hello world');<br>}<br>
            例如函数代码块中只有一行代码时<br>
            const mul = (n1,n2) => n1 + n2;<br>
            console.log(mul(30,40));<br>
            <hr>
            <h3>箭头函数中的this</h3>
            <p>箭头函数中的this引用的是最近作用域的this</p>
            <p>问题 - 箭头函数中的this是如何查找的? : 向外层作用域中,一层层查找this直到有this的定义</p>
            <p>一旦是function包含的this,那么指向就肯定是window,如果是两个箭头函数嵌套的this,那么指向的肯定是外层的对象</p>


        </li>
        <li>
            <h1>Vue Cli</h1>
            <p>创建vue项目 - vue init webpack projectname</p>
            <p>vue程序执行流程</p>
            <ol>
                <li>
                    <p>
                        template
                    </p>
                </li>
                <li>
                    <p>
                        ast
                    </p>
                </li>
                <li>
                    <p>
                        rander
                    </p>
                </li>
                <li>
                    <p>
                        virtual dom
                    </p>
                </li>
                <li>
                    <p>
                        真实 DOM
                    </p>
                </li>
            </ol>
            <hr>
            <p>
                runtime-compiler()<br>
                template -> ast -> rander -> vdom -> ui<br>
                runtime-only(1,性能更高 2,下面的vue代码量更少)<br>
                rander -> vdom -> ui<br>
            </p>
            <ol>vue-cli 3和2版本的区别
                <li>
                    <p>
                        vue-cli 3 是基于 webpack 4 打造的,vue-cli 2还是 webpack 3
                    </p>
                </li>
                <li>
                    <p>
                        vue-cli 3 的设计原则是 '0配置' ,移除的配置文件根目录下的,build和config等目录
                    </p>
                </li>
                <li>
                    <p>
                        vue-cli 3 提供了 vue ui 命令,提供了可视化配置,更加人性化
                    </p>
                </li>
                <li>
                    <p>
                        移除了 static 文件夹,新增了 public 文件夹,并且index.html 移动到 public 中
                    </p>
                </li>
            </ol>


        </li>
        <li>
            <h1>Vue-Router</h1>
            <p>什么是前端渲染,什么是后端渲染</p>
            <ol>
                <li>
                    <p>后端渲染</p>
                    <p>jsp : java server page</p>
                    <p>早期的网站开发整个HTML页面是由服务器渲染的</p>
                    <p>服务器直接生产渲染好的对应的HTML页面,由控制器路由分配,返回给客户端显示</p>
                    <p>后端路由的缺点 - 整个页面的模块都是由后端人员来编写和维护;前端开发如果要开发页面,需要通过PHP或者java来编写页面</p>
                </li>
                <li>
                    <p>前后端分离</p>
                    <p>后端只负责提供数据,不负责任何阶段的内容</p>
                    <p>前端浏览器中显示的网页中的大部分内容,都是由前端写的js代码再浏览器中执行,最终渲染出来的网页</p>
                </li>
                <li>
                    <p>单页面富应用 SPA</p>
                    <p>SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</p>
                    <p>整个页面只有一个HTML页面</p>
                    <p>核心 - 改变URL,但是页面不进行整体的刷新</p>
                </li>
            </ol>
            <p>router-link的补充</p>
            <p>router-link 除了 to ,还有一些比较常用的其他属性</p>
            <p>tag - tag可以指定 router-link 之后渲染成什么组件,比如渲染成一个button或者一个li元素等等</p>
            <p>replace - replace不会留下history记录,所以在指定replace的情况下,后退键不能返回到上一个页面中</p>
            <p>不常用 >> active-class 当router-link对应的路由匹配成功时,会自动给当前元素设置一个router-link-active的class,可以设置active-class修改默认的名称</p>
            <hr>
            <h3>动态路由</h3>
        </li>
        <li>
            <h1>Vuex</h1>
        </li>
        <li>
            <h1>Axios</h1>
        </li>
    </ul>
</body>

</html>